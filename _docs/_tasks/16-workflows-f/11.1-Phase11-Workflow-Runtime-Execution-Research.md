# Task 11.1: Workflow Runtime Execution ‚Äî Research Log

**Status:** üîç In Progress  
**Date:** December 8, 2025  
**Parent Task:** [Phase 11: Workflow Runtime Execution](./11-Phase11-Workflow-Runtime-Execution.md)

---

## How to Use This Document

This research log investigates:
1. **Current agent tool architecture** - How connection tools are loaded and used
2. **Mastra agent/tool patterns** - How Mastra agents discover and invoke tools
3. **Workflow-as-tool integration** - How to wrap workflows as tools for agents
4. **RuntimeContext patterns** - How to pass connection bindings to workflows

**Status Key:** ‚ùì Not Researched | üîç In Progress | ‚úÖ Answered | ‚ö†Ô∏è Blocked

---

## Quick Reference

| Question | Unlocks Requirement | Status |
|----------|---------------------|--------|
| [RQ-1: How are connection tools currently loaded?](#rq-1-how-are-connection-tools-currently-loaded) | AC-11.1, AC-11.2 | üîç |
| [RQ-2: How do Mastra agents discover and use tools?](#rq-2-how-do-mastra-agents-discover-and-use-tools) | AC-11.1, AC-11.2 | üîç |
| [RQ-3: Can workflows be used as tools in Mastra?](#rq-3-can-workflows-be-used-as-tools-in-mastra) | AC-11.1, AC-11.2 | üîç |
| [RQ-4: How should workflow tools be wrapped for Vercel AI SDK?](#rq-4-how-should-workflow-tools-be-wrapped-for-vercel-ai-sdk) | AC-11.1, AC-11.2 | üîç |
| [RQ-5: How does RuntimeContext work with connection bindings?](#rq-5-how-does-runtimecontext-work-with-connection-bindings) | AC-11.3 | üîç |
| [RQ-6: How do agents call tools vs workflows?](#rq-6-how-do-agents-call-tools-vs-workflows) | AC-11.2 | üîç |

---

## Part 1: Current Agent Tool Architecture

### RQ-1: How are connection tools currently loaded?

**Why It Matters:** AC-11.1, AC-11.2 ‚Äî We need to follow the same pattern for workflow tools to ensure consistency and compatibility.

**Status:** ‚úÖ Answered

**Question:** How does the chat service currently load connection tools? What's the architecture?

**Answer:**
```typescript
// 1. Chat service calls buildToolMap()
// app/api/workforce/[agentId]/chat/services/chat-service.ts
export async function buildToolMap(
  userId: string,
  agentConfig: AgentConfig
): Promise<Record<string, Tool<unknown, unknown>>> {
  const toolMap: Record<string, Tool<unknown, unknown>> = {};
  
  // Load custom tools (from _tables/tools/)
  for (const toolId of agentConfig.toolIds) {
    const toolDef = await getExecutableToolById(toolId);
    if (toolDef) {
      toolMap[toolId] = toolDef.run;  // Extract .run property
    }
  }

  // Load connection tools (from Composio)
  const connectionBindings = agentConfig.connectionToolBindings || [];
  for (const binding of connectionBindings) {
    const toolDef = await getConnectionToolExecutable(userId, binding);
    if (toolDef) {
      toolMap[binding.toolId] = toolDef.run;  // Extract .run property
    }
  }
  
  return toolMap;
}

// 2. Connection tools are wrapped with Vercel AI SDK tool()
// app/api/tools/services/composio-tools.ts
export async function getConnectionToolExecutable(
  userId: string,
  binding: ConnectionToolBinding
): Promise<ToolDefinition | undefined> {
  // ... load Composio tool schema ...
  
  const vercelTool = tool({
    description: toolDescription,
    inputSchema: zodSchema,  // Converted from Composio JSON Schema
    execute: async (input: Record<string, unknown>) => {
      // Extract actual tool args (filter out Mastra runtime context)
      const toolArgs = extractToolArguments(input);
      
      // Execute via Composio client
      const result = await client.tools.execute(binding.toolId, {
        userId,
        arguments: toolArgs,
        connectedAccountId: binding.connectionId,  // Bound connection
      });
      
      return truncateToolResult(result);
    },
  });

  return {
    id: binding.toolId,
    name: composioTool.name || binding.toolId,
    description: toolDescription,
    runtime: "composio",
    run: vercelTool as Tool<unknown, unknown>,  // This is what goes into toolMap
  };
}

// 3. ToolMap is passed to Mastra Agent
// app/api/workforce/[agentId]/chat/services/chat-service.ts
export function createConfiguredAgent(
  userId: string,
  agentConfig: AgentConfig,
  toolMap: Record<string, Tool<unknown, unknown>>  // Map of toolId -> Tool
): Agent {
  return new Agent({
    name: agentConfig.id,
    instructions: agentConfig.systemPrompt,
    model: gateway(agentConfig.model),
    tools: toolMap,  // Agent discovers tools from this map
    memory: getAgentMemory(agentConfig.id),
  });
}
```

**Primitive Discovered:**
- Function/Method: `getConnectionToolExecutable(userId, binding)`
- Signature: `(userId: string, binding: ConnectionToolBinding) => Promise<ToolDefinition | undefined>`
- Return type: `ToolDefinition` with `{ id, name, description, runtime, run }` where `run` is Vercel AI SDK `Tool`

**Implementation Note:** 
- Connection tools follow pattern: Load ‚Üí Wrap with `tool()` ‚Üí Return `ToolDefinition` with `.run` property
- Mastra Agent accepts `tools: Record<string, Tool>` - just a map of tool IDs to Vercel AI SDK tools
- Agent automatically discovers tools during chat - no special registration needed
- Workflow tools should follow the same pattern: wrap workflow execution in `tool()`, return `ToolDefinition`

**Source:** `app/api/workforce/[agentId]/chat/services/chat-service.ts` (lines 69-99), `app/api/tools/services/composio-tools.ts` (lines 265-346)

---

### RQ-2: How do Mastra agents discover and use tools?

**Why It Matters:** AC-11.1, AC-11.2 ‚Äî We need to understand how Mastra agents see and invoke tools to ensure workflow tools work the same way.

**Status:** ‚úÖ Answered

**Question:** How does a Mastra Agent instance discover and use tools? What's the tool interface?

**Answer:**
```typescript
// Mastra Agent constructor
import { Agent } from "@mastra/core/agent";
import type { Tool } from "ai";  // Vercel AI SDK Tool type

const agent = new Agent({
  name: "agent-id",
  instructions: "You are a helpful assistant...",
  model: gateway("google/gemini-2.5-pro"),
  tools: {
    "tool-id-1": tool1,  // Vercel AI SDK Tool
    "tool-id-2": tool2,
    // ... more tools
  },
  memory: memoryInstance,
});

// Agent automatically:
// 1. Discovers tools from the tools map
// 2. Makes tools available to LLM during chat
// 3. LLM decides when to call tools based on descriptions
// 4. Executes tools via their execute() function
// 5. Returns results to LLM for response generation
```

**Key Findings:**
- **Tool Interface**: Mastra uses Vercel AI SDK's `Tool<unknown, unknown>` type directly
- **Discovery**: Tools are passed as a `Record<string, Tool>` map in constructor
- **No Special Registration**: Agent automatically makes all tools in the map available
- **LLM-Driven**: Agent's LLM decides when to use tools based on tool descriptions
- **Execution**: Tools are called via their `execute()` function with input matching `inputSchema`

**Primitive Discovered:**
- Function/Method: `new Agent({ tools })`
- Signature: `Agent({ name, instructions, model, tools: Record<string, Tool>, memory })`
- Return type: `Agent` instance that can stream chat with tool access

**Implementation Note:** 
- Workflow tools just need to be Vercel AI SDK `Tool` instances
- No special Mastra-specific wrapping needed - same format as connection tools
- Tool descriptions are critical - LLM uses them to decide when to invoke tools
- Tool IDs should be descriptive (e.g., `workflow-summarize-site-email`)

**Source:** [Mastra Agents & Tools Docs](https://mastra.ai/docs/workflows/agents-and-tools), `app/api/workforce/[agentId]/chat/services/chat-service.ts` (lines 165-181)

---

## Part 2: Mastra Workflow Integration

### RQ-3: Can workflows be used as tools in Mastra?

**Why It Matters:** AC-11.1, AC-11.2 ‚Äî We need to know if Mastra has native support for workflows as tools, or if we need to wrap them.

**Status:** ‚úÖ Answered

**Question:** Can workflows be directly used as tools in Mastra agents? Or do we need to wrap them?

**Answer:**
From Mastra docs: **Workflows can be used as steps in other workflows**, but **NOT directly as tools in agents**. We need to wrap them.

**Workflows as Steps (in other workflows):**
```typescript
// From Mastra docs: workflows can be composed as steps
const nestedWorkflow = createWorkflow({ ... });
const parentWorkflow = createWorkflow({ ... })
  .then(step1)
  .then(nestedWorkflow)  // Workflow used as step
  .commit();
```

**Workflows as Tools (for agents):**
```typescript
// We need to wrap workflow execution in a tool()
import { tool } from "ai";
import { RuntimeContext } from "@mastra/core/workflows";

const workflowTool = tool({
  description: "Summarize a website and email it",
  inputSchema: workflow.inputSchema,  // Use workflow's input schema
  execute: async (input) => {
    const runtimeContext = new RuntimeContext({
      connections: { gmail: "ca_xyz" }
    });
    const run = await workflow.createRunAsync({ runtimeContext });
    const result = await run.start({ inputData: input });
    return result.result;  // Return workflow output
  }
});
```

**Primitive Discovered:**
- Function/Method: `workflow.createRunAsync()` then `.start()`
- Signature: `createRunAsync({ runtimeContext? }) => Promise<WorkflowRun>`, `run.start({ inputData, runtimeContext? }) => Promise<WorkflowResult>`
- Return type: `WorkflowRun`, then `WorkflowResult` with `{ status, result, steps }`

**Implementation Note:** 
- **We must wrap workflows** - they're not directly usable as agent tools
- Wrap with Vercel AI SDK's `tool()` function (same pattern as connection tools)
- Use workflow's `inputSchema` as tool's `inputSchema`
- Execute workflow via `createRunAsync().start()` with RuntimeContext for connections
- Return `result.result` (workflow output) to agent

**Source:** [Mastra Agents & Tools Docs](https://mastra.ai/docs/workflows/agents-and-tools) - shows workflows as steps, not as agent tools. [Mastra Workflow State Docs](https://mastra.ai/docs/workflows/workflow-state) - shows workflow execution pattern.

---

### RQ-4: How should workflow tools be wrapped for Vercel AI SDK?

**Why It Matters:** AC-11.1, AC-11.2 ‚Äî We're using Vercel AI SDK's `tool()` function. How should workflow execution fit into this pattern?

**Status:** ‚úÖ Answered

**Question:** How do connection tools use `tool()` from Vercel AI SDK? What pattern should workflow tools follow?

**Answer:**
Connection tools follow this pattern (from `composio-tools.ts`):
```typescript
import { tool } from "ai";
import type { Tool } from "ai";

const vercelTool = tool({
  description: "Tool description for LLM",
  inputSchema: z.object({ ... }),  // Zod schema
  execute: async (input: Record<string, unknown>) => {
    // 1. Extract/prepare arguments
    const toolArgs = extractToolArguments(input);
    
    // 2. Execute tool (Composio, API call, etc.)
    const result = await client.tools.execute(toolId, {
      userId,
      arguments: toolArgs,
      connectedAccountId: binding.connectionId,
    });
    
    // 3. Process/truncate result if needed
    return truncateToolResult(result);
  },
});

return {
  id: toolId,
  name: toolName,
  description: toolDescription,
  runtime: "composio",
  run: vercelTool as Tool<unknown, unknown>,  // Extract .run for toolMap
};
```

**Workflow tools should follow the same pattern:**
```typescript
import { tool } from "ai";
import { RuntimeContext } from "@mastra/core/workflows";
import { getWorkflowExecutable, getWorkflowMetadata } from "@/app/api/workflows/services/workflow-loader";

const workflow = await getWorkflowExecutable(binding.workflowId);
const metadata = await getWorkflowMetadata(binding.workflowId);

const vercelTool = tool({
  description: metadata.description || `Workflow: ${metadata.name}`,
  inputSchema: workflow.inputSchema,  // Workflow already has Zod schema
  execute: async (input: Record<string, unknown>) => {
    // 1. Create RuntimeContext with connection bindings
    const runtimeContext = new RuntimeContext({
      connections: binding.connectionBindings
    });
    
    // 2. Create workflow run
    const run = await workflow.createRunAsync({
      resourceId: userId,
      runtimeContext,
    });
    
    // 3. Execute workflow
    const result = await run.start({
      inputData: input,  // User-provided inputs
    });
    
    // 4. Handle result
    if (result.status === "success") {
      return result.result;  // Workflow output
    } else if (result.status === "failed") {
      // Extract error details from result.steps
      throw new Error(`Workflow failed: ${result.steps?.["step-id"]?.error}`);
    }
    
    return result;  // Include status for suspended/etc.
  },
});

return {
  id: `workflow-${binding.workflowId}`,
  name: metadata.name,
  description: metadata.description || `Workflow: ${metadata.name}`,
  runtime: "workflow",
  run: vercelTool as Tool<unknown, unknown>,
};
```

**Primitive Discovered:**
- Function/Method: `tool({ description, inputSchema, execute })`
- Signature: `tool(options: { description: string, inputSchema: ZodSchema, execute: (input) => Promise<output> }) => Tool`
- Return type: Vercel AI SDK `Tool<unknown, unknown>`

**Implementation Note:** 
- **Same pattern as connection tools** - wrap execution in `tool()`
- Use workflow's `inputSchema` directly (already Zod)
- Create RuntimeContext with connection bindings
- Execute via `createRunAsync().start()`
- Return `ToolDefinition` with `.run` property for toolMap
- Handle errors gracefully (don't break agent if one workflow fails)

**Source:** `app/api/tools/services/composio-tools.ts` (lines 290-331), Vercel AI SDK `tool()` function

---

## Part 3: RuntimeContext and Connection Bindings

### RQ-5: How does RuntimeContext work with connection bindings?

**Why It Matters:** AC-11.3 ‚Äî Workflows need connection IDs via RuntimeContext. How should we structure this?

**Status:** ‚úÖ Answered

**Question:** How do transpiled workflows access connections from RuntimeContext? What's the expected structure?

**Answer:**
From transpiled workflow code (`wf-MSKSYrCZ-Tfc/workflow.ts`):
```typescript
import { RuntimeContext } from "@mastra/core/workflows";

// In step execute function:
execute: async ({ inputData, runtimeContext }) => {
  // Access connections via runtimeContext.get("connections")
  const connections = runtimeContext.get("connections") as Record<string, string> | undefined;
  
  // Get specific connection ID by toolkit slug
  const connectionId = connections?.["gmail"];  // or "browser_tool", "slack", etc.
  
  // Use connection ID in Composio tool execution
  const result = await client.tools.execute("GMAIL_SEND_EMAIL", {
    arguments: inputData,
    connectedAccountId: connectionId,  // Bound connection
    dangerouslySkipVersionCheck: true
  });
  
  return result.data;
}
```

**Expected RuntimeContext structure:**
```typescript
import { RuntimeContext } from "@mastra/core/workflows";

const runtimeContext = new RuntimeContext({
  connections: {
    "gmail": "ca_abc123",      // Connection ID for Gmail toolkit
    "slack": "ca_xyz789",      // Connection ID for Slack toolkit
    "browser_tool": undefined, // NO_AUTH toolkit (no connection needed)
  }
});

// When creating workflow run:
const run = await workflow.createRunAsync({
  resourceId: userId,
  runtimeContext,  // Pass here
});

// When starting workflow:
const result = await run.start({
  inputData: { URL: "...", "Email Address": "..." },
  // runtimeContext already set in createRunAsync
});
```

**Primitive Discovered:**
- Function/Method: `new RuntimeContext({ connections })`, `runtimeContext.get("connections")`
- Signature: `RuntimeContext({ connections?: Record<string, string> })`, `get(key: string) => unknown`
- Return type: `RuntimeContext` instance, connections as `Record<string, string> | undefined`

**Implementation Note:** 
- **Structure**: `{ connections: { toolkitSlug: connectionId } }`
- **NO_AUTH toolkits**: Can have `undefined` or be omitted (e.g., `browser_tool`)
- **Access pattern**: `runtimeContext.get("connections")` then `connections?.[toolkitSlug]`
- **Binding source**: From `WorkflowBinding.connectionBindings` (set during workflow assignment)
- **Pass to workflow**: Via `createRunAsync({ runtimeContext })` - set once, available to all steps

**Source:** `_tables/workflows/wf-MSKSYrCZ-Tfc/workflow.ts` (lines 10-13, 32-35, 54-57), [Mastra Workflow State Docs](https://mastra.ai/docs/workflows/workflow-state)

---

### RQ-6: How do agents call tools vs workflows?

**Why It Matters:** AC-11.2 ‚Äî We need to understand if there's a difference in how agents invoke tools vs workflows.

**Status:** ‚úÖ Answered

**Question:** Is there a difference in how Mastra agents invoke regular tools vs workflows? Do workflows need special handling?

**Answer:**
**No difference from agent's perspective!** Once wrapped as tools, workflows are treated identically to connection tools.

**Agent's view (both are just tools):**
```typescript
// Agent sees both as tools in the tools map
const toolMap = {
  "GMAIL_SEND_EMAIL": connectionTool,        // Connection tool
  "workflow-summarize-site-email": workflowTool,  // Workflow tool (wrapped)
};

// Agent automatically:
// 1. Sees both tools in available toolset
// 2. LLM decides which to use based on descriptions
// 3. Calls execute() function (same interface)
// 4. Receives result (same format)
// 5. Uses result in response generation
```

**Execution flow (same for both):**
```typescript
// Connection tool execution
tool.execute(input) 
  ‚Üí Composio client.tools.execute()
  ‚Üí Returns result

// Workflow tool execution (wrapped)
tool.execute(input)
  ‚Üí Create RuntimeContext
  ‚Üí workflow.createRunAsync({ runtimeContext })
  ‚Üí run.start({ inputData: input })
  ‚Üí Returns workflow result
```

**Key Insight:** The wrapping layer makes workflows look like regular tools to the agent. The agent doesn't know or care that one is a workflow - it just sees tools with descriptions and executes them.

**Primitive Discovered:**
- Function/Method: Agent calls `tool.execute(input)` for both types
- Signature: `execute(input: Record<string, unknown>) => Promise<unknown>`
- Return type: `Promise<unknown>` (result returned to agent)

**Implementation Note:** 
- **No special handling needed** - workflows wrapped as tools work identically
- Agent's LLM uses tool descriptions to decide when to invoke
- Tool descriptions are critical - should clearly describe what workflow does
- Tool IDs should be descriptive (e.g., `workflow-summarize-site-email`)
- Error handling should be consistent - both should throw errors that agent can understand

**Source:** [Mastra Agents & Tools Docs](https://mastra.ai/docs/workflows/agents-and-tools), `app/api/workforce/[agentId]/chat/services/chat-service.ts` (lines 69-99)

---

## Summary

### Primitives We'll Use

| What | Primitive | From | Confirmed? |
|------|-----------|------|------------|
| Load connection tools | `getConnectionToolExecutable(userId, binding)` | `app/api/tools/services/composio-tools.ts` | ‚úÖ |
| Create Mastra agent | `new Agent({ tools: toolMap })` | `@mastra/core/agent` | ‚úÖ |
| Wrap tool for Vercel AI SDK | `tool({ description, inputSchema, execute })` | `ai` package | ‚úÖ |
| Execute workflow | `workflow.createRunAsync({ runtimeContext }).then(run => run.start({ inputData }))` | `@mastra/core/workflows` | ‚úÖ |
| Create RuntimeContext | `new RuntimeContext({ connections: {...} })` | `@mastra/core/workflows` | ‚úÖ |
| Load workflow executable | `getWorkflowExecutable(workflowId)` | `app/api/workflows/services/workflow-loader.ts` | ‚úÖ |
| Load workflow metadata | `getWorkflowMetadata(workflowId)` | `app/api/workflows/services/workflow-loader.ts` | ‚úÖ |

### Blockers & Dead Ends

| Issue | Impact | Resolution |
|-------|--------|------------|
| - | - | - |

### Key Learnings

1. **Workflows must be wrapped as tools** - Mastra doesn't support workflows directly as agent tools. We wrap workflow execution in Vercel AI SDK's `tool()` function, following the same pattern as connection tools.

2. **Agent tool interface is simple** - Mastra Agent accepts `tools: Record<string, Tool>` where `Tool` is from Vercel AI SDK. No special registration or discovery needed - agent automatically makes all tools available to the LLM.

3. **RuntimeContext pattern is established** - Transpiled workflows access connections via `runtimeContext.get("connections")` as `Record<string, string>`. We create RuntimeContext with connection bindings from `WorkflowBinding.connectionBindings` and pass it via `createRunAsync({ runtimeContext })`.

4. **Tool wrapping pattern is consistent** - Both connection tools and workflow tools follow the same pattern: load ‚Üí wrap with `tool()` ‚Üí return `ToolDefinition` with `.run` property ‚Üí add to `toolMap` ‚Üí pass to Agent constructor.

5. **Workflow inputSchema is already Zod** - Workflows have `inputSchema` as Zod schemas from transpiler, so we can use them directly as tool `inputSchema` - no conversion needed.

6. **Error handling should be graceful** - If a workflow fails to load, we should log a warning and continue (don't break agent chat). Same pattern as connection tools.

---

## Exit Criteria

- [x] All RQ questions answered
- [x] Summary table complete
- [x] No unresolved blockers
- [x] Key learnings documented

**Next Step:** Update Phase 11 implementation plan based on research findings

---

## Implementation Plan Updates

Based on research findings, the Phase 11 implementation should:

1. **Follow connection tools pattern exactly** - Use same `ToolDefinition` structure, same error handling, same toolMap integration
2. **Wrap workflows with `tool()`** - Use Vercel AI SDK's `tool()` function, not Mastra-specific wrapping
3. **Use workflow's inputSchema directly** - No conversion needed, already Zod
4. **Create RuntimeContext with connections** - Structure: `{ connections: { toolkitSlug: connectionId } }`
5. **Execute via createRunAsync().start()** - Standard Mastra workflow execution pattern
6. **Return ToolDefinition with .run** - Extract `.run` property for toolMap (same as connection tools)
7. **Integrate in buildToolMap()** - Add workflow tools alongside connection tools and custom tools

---

## Resources Used

- [Mastra Agents & Tools Docs](https://mastra.ai/docs/workflows/agents-and-tools)
- [Mastra Workflow State Docs](https://mastra.ai/docs/workflows/workflow-state)
- Existing code: `app/api/workforce/[agentId]/chat/services/chat-service.ts`
- Existing code: `app/api/tools/services/composio-tools.ts`
- Existing code: `app/api/tools/services/custom-tools.ts`
- Existing code: `_tables/workflows/wf-MSKSYrCZ-Tfc/workflow.ts`

