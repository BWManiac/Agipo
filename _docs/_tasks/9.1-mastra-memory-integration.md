# Task 9.1: Mastra Memory Integration

**Status:** Phase 9.1e Complete, Phase 9.1f Optional  
**Date:** December 5, 2025  
**Priority:** High  
**Dependencies:** Task 9 (Mastra Migration) - Complete  
**Parent Task:** Task 9: Mastra Migration

### Phases Overview
| Phase | Name | Status |
|-------|------|--------|
| 9.1a | UXD Mockups | ✅ Complete |
| 9.1b | Basic Conversation Persistence | ✅ Complete |
| 9.1c | Frontend Implementation (AI Elements) | ✅ Complete |
| 9.1d | Thread Management APIs | ✅ Complete |
| 9.1e | Working Memory & Knowledge Tab | ✅ Complete |
| 9.1e.1 | Bug Fix: Message Persistence on Thread Switch | ✅ Complete |
| 9.1f | Semantic Recall | ⏳ Optional |

### UXD Mockups (Complete)
- `_docs/UXD/Pages/agents/variation-1/threads-sidebar.html` ✅
- `_docs/UXD/Pages/agents/variation-1/knowledge-tab.html` ✅
- `_docs/UXD/Pages/agents/variation-1/thread-management.html` ✅

---

## 1. Executive Summary

This task implements Mastra's Memory system to enable conversation persistence, semantic recall, and working memory for agents. The goal is to make agents "remember" conversations and learn user preferences over time.

### Why This Matters

| Current State | Target State |
|--------------|--------------|
| Conversations lost on page refresh | Conversations persist across sessions |
| No memory between sessions | Agent recalls relevant past context |
| Agent doesn't learn user preferences | Agent maintains "knowledge" about each user |
| Recent Conversations UI is static | Real threads, clickable, deletable |

---

## 2. Acceptance Criteria

### Phase 9.1b: Conversation Persistence (AC 1-5)

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC1 | Messages are saved to storage after each turn | Check storage after sending message | 9.1b ✅ |
| AC2 | Reloading page preserves conversation history | Refresh browser, verify messages appear | 9.1b ✅ |
| AC3 | Each conversation has a unique `threadId` | Inspect storage, verify thread structure | 9.1b ✅ |
| AC4 | Threads are scoped by `userId` (from Clerk) | Different users see different threads | 9.1b ✅ |
| AC5 | Agent receives last N messages as context | Ask "what did I just say?", agent recalls | 9.1b ✅ |

### Phase 9.1c: Frontend Implementation (AC 6-20)

**Thread Sidebar (AC 6-10)**

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC6 | "New Conversation" button renders at top of sidebar | Visual inspection | 9.1c |
| AC7 | Clicking "New Conversation" creates empty chat | Click → verify new threadId | 9.1c |
| AC8 | Thread list shows threads from state | Compare sidebar to data | 9.1c |
| AC9 | Active thread is visually highlighted | Visual inspection | 9.1c |
| AC10 | Hovering inactive thread shows delete button | Hover → verify trash icon | 9.1c |

**Thread Selection (AC 11-13)**

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC11 | Clicking a thread loads its messages | Click → messages populate | 9.1c |
| AC12 | Thread header updates to show thread's title | Verify header changes | 9.1c |
| AC13 | Loading state shows while fetching | Verify spinner | 9.1c |

**Thread Header (AC 14-16)**

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC14 | Header displays title and "Started X ago" | Visual inspection | 9.1c |
| AC15 | Clicking "Rename" enables inline editing | Click → input editable | 9.1c |
| AC16 | Saving rename updates UI | Edit → save → verify | 9.1c |

**Delete Flow (AC 17-18)**

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC17 | Clicking delete opens confirmation dialog | Click → dialog appears | 9.1c |
| AC18 | Confirming delete removes thread from sidebar | Confirm → verify removal | 9.1c |

**Chat UI with AI Elements (AC 19-20)**

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC19 | Messages render using AI Elements | Inspect DOM for classes | 9.1c |
| AC20 | Input uses PromptInput with submit | Verify render & submit | 9.1c |

### Phase 9.1d: Thread APIs (AC 21-26)

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC21 | GET /threads returns user's threads | API call returns list | 9.1d |
| AC22 | POST /threads creates new thread | API creates, returns ID | 9.1d |
| AC23 | GET /threads/[id] returns messages | API returns thread data | 9.1d |
| AC24 | PATCH /threads/[id] updates title | API updates, returns | 9.1d |
| AC25 | DELETE /threads/[id] removes thread | API deletes | 9.1d |
| AC26 | All endpoints scoped by userId | Different users isolated | 9.1d |

### Phase 9.1e: Working Memory & Knowledge Tab (AC 27-35)

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC27 | Working memory enabled in config | Check memory.ts | 9.1e |
| AC28 | Agent updates working memory autonomously | Chat → check storage | 9.1e |
| AC29 | Working memory persists across sessions | New chat → still knows | 9.1e |
| AC30 | Working memory scoped per user | Different users isolated | 9.1e |
| AC31 | Knowledge tab in agent modal header | Visual inspection | 9.1e |
| AC32 | Knowledge tab displays all sections | Visual inspection | 9.1e |
| AC33 | "Last updated X ago" timestamp | Visual inspection | 9.1e |
| AC34 | "Clear all memory" with confirmation | Click → dialog → clear | 9.1e |
| AC35 | Empty state when no knowledge | Visual inspection | 9.1e |

### Phase 9.1f: Semantic Recall - Optional (AC 36-38)

| # | Criterion | Test | Phase |
|---|-----------|------|-------|
| AC36 | Messages embedded in vector DB | Check vector storage | 9.1f |
| AC37 | Agent retrieves relevant past messages | Ask old topic → recalls | 9.1f |
| AC38 | Semantic search respects user scope | Users isolated | 9.1f |

---

## 3. User Flows

### Flow 1: Continuing a Past Conversation

```
1. User opens agent modal
2. User sees "Recent Conversations" sidebar with past threads
3. User clicks "Admin Dashboard Latency" thread
4. Chat loads with previous messages
5. User sends new message
6. Agent responds with context from earlier in thread
```

### Flow 2: Starting Fresh

```
1. User opens agent modal
2. User clicks "New Conversation" button
3. Empty chat appears with fresh threadId
4. User sends first message
5. Thread appears in "Recent Conversations" sidebar
6. Thread title auto-generates from first message
```

### Flow 3: Agent Remembers User Preferences

```
1. User tells agent "I prefer bullet points over paragraphs"
2. Agent acknowledges and updates working memory
3. Days later, user starts new conversation
4. Agent's responses use bullet points (remembers preference)
```

### Flow 4: Deleting a Conversation

```
1. User hovers over thread in sidebar
2. Delete icon appears
3. User clicks delete
4. Confirmation dialog appears
5. User confirms
6. Thread removed from sidebar and storage
```

### Flow 5: Viewing Agent's Knowledge

```
1. User clicks "Knowledge" tab in agent modal
2. Tab displays working memory in formatted view
3. Shows: Communication Preferences, Active Projects, Key Context
4. User can see what agent "knows" about them
```

---

## 4. Technical Architecture

### Storage Backend: LibSQL

LibSQL creates **SQLite database files** that store:
- Threads (conversations)
- Messages (within threads)
- Working memory (per user/thread)

**Per-Agent Storage Structure:**
```
_tables/
  agents/
    mira-patel/
      config.ts           # Existing agent config
      memory.db           # Mira's conversations & memory
      memory.db-wal       # (temporary) Write-ahead log
      memory.db-shm       # (temporary) Shared memory
    alex-kim/
      config.ts
      memory.db
    elena-park/
      config.ts
      memory.db
```

**Note:** The `-wal` and `-shm` files are temporary SQLite files:
- **WAL (Write-Ahead Log):** Buffer for writes before merging into main DB
- **SHM (Shared Memory):** Coordination file for concurrent access
- Both are auto-managed and only exist while database is active

**Why LibSQL over PostgreSQL:**
- Zero infrastructure (just files)
- Schema can evolve easily
- Per-agent isolation (each agent has own database)
- Good for development/prototyping
- Already in `.gitignore` (under `_tables/agents/`)
- Can migrate to PostgreSQL later if needed

### Memory Configuration

```typescript
// app/api/workforce/[agentId]/chat/services/memory.ts

import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";
import { workingMemorySchema } from "../types/working-memory";

// Factory function to create per-agent memory instance
export function getAgentMemory(agentId: string): Memory {
  return new Memory({
    storage: new LibSQLStore({
      url: `file:./_tables/agents/${agentId}/memory.db`,
    }),
    options: {
      lastMessages: 10,
      workingMemory: {
        enabled: true,
        scope: 'resource',  // Per user, across all conversations
        schema: workingMemorySchema,  // Zod schema
      },
      threads: {
        generateTitle: true,  // Auto-generate from first message
      },
    },
  });
}
```

### Working Memory Schema (Zod)

```typescript
// app/api/workforce/[agentId]/chat/types/working-memory.ts

import { z } from "zod";

export const workingMemorySchema = z.object({
  communicationPreferences: z.object({
    style: z.enum(["formal", "casual", "technical"]).optional(),
    responseLength: z.enum(["concise", "detailed"]).optional(),
    formatPreference: z.enum(["paragraphs", "bullets", "mixed"]).optional(),
  }).optional(),
  
  activeProjects: z.array(z.object({
    name: z.string(),
    status: z.enum(["active", "blocked", "completed"]).optional(),
    notes: z.string().optional(),
  })).optional(),
  
  keyContext: z.array(z.string()).optional(),
  
  recentDecisions: z.array(z.object({
    decision: z.string(),
    date: z.string().optional(),
  })).optional(),
});

export type WorkingMemory = z.infer<typeof workingMemorySchema>;
```

---

## 5. Implementation Phases

### Phase 9.1a: UXD Mockups

**Goal:** Create clear visual targets before touching code. Design the UI for memory-related features.

#### File Impact Analysis

| File | Change | Priority |
|------|--------|----------|
| `_docs/UXD/Pages/agents/variation-1/threads-sidebar.html` | NEW: Recent Conversations sidebar mockup | P0 |
| `_docs/UXD/Pages/agents/variation-1/knowledge-tab.html` | NEW: Agent Knowledge tab mockup | P0 |
| `_docs/UXD/Pages/agents/variation-1/thread-management.html` | NEW: Thread switching, new chat, delete UI | P1 |

#### Mockup Requirements

**1. Threads Sidebar (Recent Conversations)**
- List of past conversations with titles
- Timestamps (relative: "2 hours ago", "Yesterday")
- Active thread highlighted
- Hover state shows delete button
- "New Chat" button at top
- Empty state when no conversations

**2. Knowledge Tab**
- Tab in agent modal header (alongside Chat, Tasks, etc.)
- Displays working memory in readable format
- Sections: Communication Preferences, Active Projects, Key Context
- Read-only initially
- Empty state when no knowledge yet

**3. Thread Management**
- Click thread → loads conversation
- Click "New Chat" → starts fresh thread
- Delete confirmation dialog
- Thread title display in chat header

#### Acceptance Criteria for Phase

- [x] Threads sidebar mockup complete
- [x] Knowledge tab mockup complete
- [x] Delete confirmation dialog mockup complete
- [x] Empty states designed

#### Testing

Visual review and approval before proceeding to backend. ✅ **APPROVED**

---

### Phase 9.1b: Basic Conversation Persistence ✅ COMPLETE

**Goal:** Messages save and load from storage. Conversations persist across page refreshes.

#### File Impact Analysis (Actual)

| File | Action | Lines | Description |
|------|--------|-------|-------------|
| `package.json` | MODIFIED | +2 | Added `@mastra/memory`, `@mastra/libsql` |
| `app/api/workforce/[agentId]/chat/route.ts` | MODIFIED | +15 | Add memory, threadId, resourceId, X-Thread-Id header |
| `app/api/workforce/[agentId]/chat/services/memory.ts` | NEW | 46 | Factory function for per-agent Memory |
| `app/api/workforce/[agentId]/chat/types/working-memory.ts` | NEW | 30 | Zod schema for working memory |
| `CLAUDE.MD` | MODIFIED | +5 | Document new dependencies |

**Total: 2 new files, 3 modified files, ~95 lines added**

#### Key Syntax & Primitives Learned

```typescript
// 1. Memory Factory Pattern
import { Memory } from "@mastra/memory";
import { LibSQLStore } from "@mastra/libsql";

export function getAgentMemory(agentId: string): Memory {
  return new Memory({
    storage: new LibSQLStore({
      url: `file:./_tables/agents/${agentId}/memory.db`,
    }),
    options: {
      lastMessages: 10,                    // Context window
      workingMemory: { enabled: true, scope: 'resource', schema },
      threads: { generateTitle: true },    // Auto-title from first message
    },
  });
}

// 2. Agent with Memory
const dynamicAgent = new Agent({
  name: agentConfig.id,
  instructions: agentConfig.systemPrompt,
  model: gateway(agentConfig.model),
  tools: toolMap,
  memory: getAgentMemory(agentId),  // Attach memory instance
});

// 3. Stream with Memory Context
const result = await dynamicAgent.stream(messages, {
  threadId,              // Conversation identifier
  resourceId: userId,    // User identifier (from Clerk)
  format: 'aisdk',       // Return AI SDK compatible stream
});

// 4. Return threadId to Frontend
const response = result.toUIMessageStreamResponse();
response.headers.set("X-Thread-Id", threadId);  // Frontend stores this
```

#### Acceptance Criteria ✅

- [x] AC1: Messages saved to storage after each turn
- [x] AC2: Reloading page preserves conversation history
- [x] AC3: Each conversation has unique `threadId`
- [x] AC4: Threads scoped by `userId` (from Clerk)
- [x] AC5: Agent receives last N messages as context

#### Reference Links

- [Mastra Memory Overview](https://mastra.ai/docs/memory/overview)
- [Mastra LibSQL Storage](https://mastra.ai/docs/memory/libsql)
- [Mastra Agent Memory Integration](https://mastra.ai/docs/agents/memory)

---

### Phase 9.1c: Frontend Implementation (Chat UI with AI Elements) ✅ COMPLETE

**Goal:** Build a modern chat interface using AI Elements, replacing the existing ChatTab with a modular component structure that supports thread management.

#### Design Reference

UXD Mockups: `_docs/UXD/Pages/agents/variation-1/`
- `thread-management.html` - Full chat view with sidebar + header
- `threads-sidebar.html` - Thread list states (populated, empty, hover)
- `knowledge-tab.html` - Agent knowledge display

#### Component Architecture (Implemented)

```
tabs/
  ChatTab/                              # Folder (replaced ChatTab.tsx)
    index.tsx                           # Main orchestration (105 lines)
    types.ts                            # Thread, ThreadMessage types (25 lines)
    components/
      ThreadSidebar.tsx                 # Thread list with CRUD (128 lines)
      ThreadHeader.tsx                  # Title + rename (130 lines)
      ChatArea.tsx                      # AI Elements chat (138 lines)
      DeleteThreadDialog.tsx            # Confirmation modal (41 lines)
    hooks/
      useThreads.tsx                    # Thread state management (82 lines)
      useChatMemory.tsx                 # Chat with memory (87 lines)
```

#### AI Elements Usage (Actual)

| Component | Source | Usage |
|-----------|--------|-------|
| `Conversation` | `ai-elements/conversation.tsx` | Main chat container with auto-scroll |
| `ConversationContent` | `ai-elements/conversation.tsx` | Message list wrapper |
| `ConversationEmptyState` | `ai-elements/conversation.tsx` | "Start a conversation" state |
| `ConversationScrollButton` | `ai-elements/conversation.tsx` | Scroll to bottom button |
| `Message` | `ai-elements/message.tsx` | Message wrapper (user/assistant) |
| `MessageContent` | `ai-elements/message.tsx` | Message text container |
| `MessageResponse` | `ai-elements/message.tsx` | Markdown rendering with Streamdown |
| `PromptInput` | `ai-elements/prompt-input.tsx` | Rich input container |
| `PromptInputTextarea` | `ai-elements/prompt-input.tsx` | Text input area |
| `PromptInputSubmit` | `ai-elements/prompt-input.tsx` | Send button (not PromptInputActions!) |

#### shadcn/ui Usage (Actual)

| Component | Usage |
|-----------|-------|
| `Button` | New Conversation, Rename save/cancel |
| `ScrollArea` | Thread sidebar scroll |
| `AlertDialog` | Delete confirmation |
| `Input` | Inline title rename |
| `Tooltip` | Delete button hover text |

#### File Impact Analysis (Actual)

| File | Action | Lines | Description |
|------|--------|-------|-------------|
| `tabs/ChatTab.tsx` | DELETED | -70 | Replaced by folder |
| `tabs/ChatTab/index.tsx` | NEW | 105 | Main orchestration |
| `tabs/ChatTab/types.ts` | NEW | 25 | Thread, ThreadMessage types |
| `tabs/ChatTab/components/ThreadSidebar.tsx` | NEW | 128 | Thread list with new/delete |
| `tabs/ChatTab/components/ThreadHeader.tsx` | NEW | 130 | Title + inline rename |
| `tabs/ChatTab/components/ChatArea.tsx` | NEW | 138 | AI Elements messages + input |
| `tabs/ChatTab/components/DeleteThreadDialog.tsx` | NEW | 41 | Delete confirmation |
| `tabs/ChatTab/hooks/useThreads.tsx` | NEW | 82 | Thread CRUD state |
| `tabs/ChatTab/hooks/useChatMemory.tsx` | NEW | 87 | useChat + memory wrapper |

**Total: 9 new files, 1 deleted file, ~736 lines added, ~70 lines removed**

#### Key Syntax & Primitives Learned

```typescript
// 1. AI Elements Message Pattern
import { Message, MessageContent, MessageResponse } from "@/components/ai-elements/message";

<Message from={message.role}>
  {isAssistant && <Avatar />}
  <MessageContent className={isUser ? "user-styles" : ""}>
    {isAssistant ? (
      <MessageResponse>{textContent}</MessageResponse>  // Markdown!
    ) : (
      <span>{textContent}</span>
    )}
  </MessageContent>
  {isUser && <Avatar />}
</Message>

// 2. AI Elements Conversation (auto-scroll)
import { Conversation, ConversationContent, ConversationEmptyState } from "@/components/ai-elements/conversation";

<Conversation>
  {isEmpty ? (
    <ConversationEmptyState title="Start a conversation" icon={emoji} />
  ) : (
    <ConversationContent>{messages.map(...)}</ConversationContent>
  )}
  <ConversationScrollButton />
</Conversation>

// 3. AI Elements PromptInput
import { PromptInput, PromptInputTextarea, PromptInputSubmit } from "@/components/ai-elements/prompt-input";

<PromptInput onSubmit={handleSubmit}>
  <PromptInputTextarea value={input} onChange={...} placeholder="Message..." />
  <PromptInputSubmit disabled={!input.trim()}>
    <SendHorizontal />
  </PromptInputSubmit>
</PromptInput>

// 4. useChatMemory Hook Pattern
const { messages, sendMessage, isStreaming } = useChatMemory({
  agentId,
  agentName,
  threadId,
  defaultPrompt,
  onFirstMessage: (preview) => updateThreadTitle(threadId, preview),
});
```

#### Acceptance Criteria ✅

**Thread Sidebar (AC 6-10)**

| # | Criterion | Status |
|---|-----------|--------|
| AC6 | "New Conversation" button renders at top of sidebar | ✅ |
| AC7 | Clicking "New Conversation" creates empty chat with new threadId | ✅ |
| AC8 | Thread list shows threads (mock data, wired to API in 9.1d) | ✅ |
| AC9 | Active thread is visually highlighted | ✅ |
| AC10 | Hovering inactive thread shows delete button | ✅ |

**Thread Selection (AC 11-13)**

| # | Criterion | Status |
|---|-----------|--------|
| AC11 | Clicking a thread loads its messages | ✅ |
| AC12 | Thread header updates to show selected thread's title | ✅ |
| AC13 | Loading state shows while fetching messages | ✅ |

**Thread Header (AC 14-16)**

| # | Criterion | Status |
|---|-----------|--------|
| AC14 | Header displays thread title and "Started X ago" timestamp | ✅ |
| AC15 | Clicking "Rename" enables inline title editing | ✅ |
| AC16 | Saving rename updates UI | ✅ |

**Delete Flow (AC 17-18)**

| # | Criterion | Status |
|---|-----------|--------|
| AC17 | Clicking delete button opens confirmation dialog | ✅ |
| AC18 | Confirming delete removes thread from sidebar | ✅ |

**Chat UI with AI Elements (AC 19-20)**

| # | Criterion | Status |
|---|-----------|--------|
| AC19 | Messages render using AI Elements `Message` and `MessageResponse` | ✅ |
| AC20 | Input uses AI Elements `PromptInput` with submit functionality | ✅ |

#### User Flows (All Implemented)

**Flow A: Starting a New Conversation** ✅
```
1. User opens agent modal → Chat tab selected
2. User sees thread sidebar with past conversations
3. User clicks "New Conversation" button
4. Thread header shows "New Conversation" (italic, pending title)
5. User types message in PromptInput
6. User presses Enter or clicks send
7. Message appears, agent responds
8. Thread title auto-generates from first message
9. New thread appears in sidebar
```

**Flow B: Continuing a Past Conversation** ✅
```
1. User opens agent modal → Chat tab selected
2. User sees recent threads in sidebar
3. User clicks thread
4. Chat loads with previous messages (mock data, API in 9.1d)
5. User sends follow-up message
6. Agent responds with context from earlier
```

**Flow C: Deleting a Conversation** ✅
```
1. User hovers over thread in sidebar
2. Trash icon appears on right side
3. User clicks trash icon
4. Confirmation dialog appears: "Delete this conversation?"
5. User clicks "Delete" button
6. Thread removed from sidebar
7. If was active, clears selection
```

#### Reference Links

- [Vercel AI Elements](https://ai-sdk.dev/elements) - Component library docs
- [AI Elements Changelog](https://vercel.com/changelog/introducing-ai-elements) - Announcement
- [Streamdown](https://www.npmjs.com/package/streamdown) - Markdown renderer used by MessageResponse
- [use-stick-to-bottom](https://www.npmjs.com/package/use-stick-to-bottom) - Auto-scroll behavior

#### Gotchas & Lessons Learned

1. **PromptInputActions doesn't exist** - Use `PromptInputSubmit` instead
2. **Conversation needs ConversationScrollButton** - Not automatic
3. **Message parts array** - Extract text with `.filter(p => p.type === "text")`
4. **MessageResponse for markdown** - Use for assistant messages only

---

### Phase 9.1d: Thread Management APIs ✅ COMPLETE

**Goal:** Backend API endpoints for thread CRUD operations, connecting frontend to persistent storage.

#### File Impact Analysis (Actual)

| File | Action | Lines | Description |
|------|--------|-------|-------------|
| `app/api/workforce/[agentId]/threads/route.ts` | NEW | 62 | GET (list), POST (create) |
| `app/api/workforce/[agentId]/threads/[threadId]/route.ts` | NEW | 99 | GET, PATCH, DELETE |
| `app/api/workforce/[agentId]/threads/services/thread-service.ts` | NEW | 145 | Service layer for memory operations |
| `tabs/ChatTab/hooks/useThreads.tsx` | MODIFIED | +100 | Wired to real APIs, added refresh |

**Total: 3 new files, 1 modified file, ~406 lines added**

#### API Endpoints (Implemented)

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| `/api/workforce/[agentId]/threads` | GET | ✓ | List user's threads for agent |
| `/api/workforce/[agentId]/threads` | POST | ✓ | Create new thread |
| `/api/workforce/[agentId]/threads/[threadId]` | GET | ✓ | Get thread with messages |
| `/api/workforce/[agentId]/threads/[threadId]` | PATCH | ✓ | Rename thread |
| `/api/workforce/[agentId]/threads/[threadId]` | DELETE | ✓ | Delete thread |

#### Key Mastra Memory Methods (Used)

```typescript
// Memory instance methods we use in thread-service.ts

// List all threads for a user
memory.getThreadsByResourceId({
  resourceId: userId,
  orderBy: "updatedAt",
  sortDirection: "DESC",
})

// Get a single thread
memory.getThreadById({ threadId })

// Create a new thread
memory.createThread({
  resourceId: userId,
  title: "New Conversation",
  saveThread: true,  // Important: persist immediately
})

// Update thread (title, etc.)
memory.saveThread({
  thread: { ...existing, title: newTitle, updatedAt: new Date() },
})

// Delete a thread
memory.deleteThread(threadId)

// Get messages for a thread
memory.query({ threadId, resourceId })
// Returns: { messages, uiMessages, messagesV2 }
```

#### Acceptance Criteria ✅

- [x] AC21: GET /threads returns list of user's threads for agent
- [x] AC22: POST /threads creates new thread in storage
- [x] AC23: GET /threads/[id] returns thread with messages
- [x] AC24: PATCH /threads/[id] updates thread title
- [x] AC25: DELETE /threads/[id] removes thread from storage
- [x] AC26: All endpoints scoped by userId from Clerk

#### User Flows (All Implemented)

**Flow A: List Threads** ✅
```
1. User opens Chat tab
2. useThreads hook calls GET /api/workforce/[agentId]/threads
3. API queries memory.db via Memory.getThreadsByResourceId()
4. Returns threads sorted by updatedAt descending
5. Sidebar populates with real threads
```

**Flow B: Load Thread Messages** ✅
```
1. User clicks thread in sidebar
2. selectThread updates activeThreadId
3. useChatMemory passes threadId to API
4. Chat route loads messages from memory
```

**Flow C: Rename Thread** ✅
```
1. User clicks Rename → edits → saves
2. useThreads.renameThread() optimistically updates UI
3. Calls PATCH /api/workforce/[agentId]/threads/[threadId]
4. API calls memory.saveThread()
```

**Flow D: Delete Thread** ✅
```
1. User clicks delete → confirms in dialog
2. useThreads.deleteThread() optimistically removes from UI
3. Calls DELETE /api/workforce/[agentId]/threads/[threadId]
4. API calls memory.deleteThread()
```

#### Reference Links

- [Mastra Memory API](https://mastra.ai/docs/memory/overview)
- [@mastra/core/dist/memory/memory.d.ts](node_modules/@mastra/core/dist/memory/memory.d.ts) - Type definitions

---

### Phase 9.1e: Working Memory & Knowledge Tab ✅ COMPLETE

**Goal:** Agent maintains knowledge about users that persists across sessions, with UI to view it.

#### File Impact Analysis (Actual)

| File | Action | Lines | Description |
|------|--------|-------|-------------|
| `app/api/workforce/[agentId]/knowledge/route.ts` | NEW | 67 | GET, DELETE working memory |
| `app/api/workforce/[agentId]/knowledge/services/knowledge-service.ts` | NEW | 72 | Service layer for working memory |
| `tabs/KnowledgeTab/index.tsx` | NEW | 210 | Knowledge tab container |
| `tabs/KnowledgeTab/types.ts` | NEW | 28 | Type definitions |
| `tabs/KnowledgeTab/components/KnowledgeSection.tsx` | NEW | 105 | Section display components |
| `tabs/KnowledgeTab/components/ClearMemoryDialog.tsx` | NEW | 45 | Clear confirmation dialog |
| `tabs/KnowledgeTab/hooks/useKnowledge.tsx` | NEW | 85 | Data fetching hook |
| `agent-modal/AgentModal.tsx` | MODIFIED | +5 | Import and render KnowledgeTab |
| `agent-modal/components/AgentHeader.tsx` | MODIFIED | +5 | Add Knowledge tab with icon |

**Total: 7 new files, 2 modified files, ~620 lines added**

#### API Endpoints (Implemented)

| Endpoint | Method | Auth | Description |
|----------|--------|------|-------------|
| `/api/workforce/[agentId]/knowledge` | GET | ✓ | Get user's working memory |
| `/api/workforce/[agentId]/knowledge` | DELETE | ✓ | Clear all working memory |

#### Key Mastra Memory Methods (Used)

```typescript
// Get working memory
memory.getWorkingMemory({ threadId, resourceId })
// Returns: string | null (JSON stringified working memory)

// Update working memory (for clearing)
memory.updateWorkingMemory({
  threadId,
  resourceId,
  workingMemory: JSON.stringify({}),  // Empty object to clear
})
```

#### Acceptance Criteria ✅

- [x] AC27: Working memory enabled in Memory config (already in 9.1b)
- [x] AC28: Agent can update working memory (schema defines structure)
- [x] AC29: Working memory persists across sessions (LibSQL storage)
- [x] AC30: Working memory scoped per user (resourceId)
- [x] AC31: Knowledge tab added to agent modal header (with Lightbulb icon)
- [x] AC32: Knowledge tab displays all working memory sections
- [x] AC33: "Last updated X ago" timestamp shown
- [x] AC34: "Clear all memory" button with confirmation dialog
- [x] AC35: Empty state shown when no knowledge yet

#### User Flows (All Implemented)

**Flow A: View Agent's Knowledge** ✅
```
1. User opens agent modal
2. User clicks "Knowledge" tab (with lightbulb icon)
3. useKnowledge hook fetches GET /knowledge
4. Tab displays sections: Communication Preferences, Active Projects, Key Context, Recent Decisions
5. Shows "Last updated X ago" timestamp
```

**Flow B: Clear Agent's Memory** ✅
```
1. User clicks "Clear All" button
2. ClearMemoryDialog opens with warning
3. User confirms
4. DELETE /knowledge called
5. Empty state displayed
```

#### Reference Links

- [Mastra Working Memory](https://mastra.ai/docs/memory/working-memory)
- Knowledge tab mockup: `_docs/UXD/Pages/agents/variation-1/knowledge-tab.html`

---

### Phase 9.1e.1: Bug Fix - Message Persistence on Thread Switch ✅ COMPLETE

**Problem:** When switching between threads, messages weren't loading - conversations appeared empty when revisited.

**Root Cause:** The `useChatMemory` hook was clearing messages on thread change but never fetching existing messages from the API.

**Fix:** Added message loading when `threadId` changes:
1. Fetch messages from `/api/workforce/[agentId]/threads/[threadId]`
2. Convert to UIMessage format
3. Set messages in chat state

#### File Impact Analysis

| File | Action | Lines | Description |
|------|--------|-------|-------------|
| `hooks/useChatMemory.tsx` | MODIFIED | +40 | Added message loading on thread switch |
| `components/ChatArea.tsx` | MODIFIED | +10 | Added loading state UI |
| `ChatTab/index.tsx` | MODIFIED | +2 | Pass isLoadingMessages prop |
| `threads/services/thread-service.ts` | MODIFIED | +55 | Added `extractMessageContent()` to parse complex message formats |

#### Key Code Changes

```typescript
// useChatMemory.tsx - Load messages when thread changes
useEffect(() => {
  async function loadThreadMessages() {
    setMessages([]);
    if (!threadId || threadId.startsWith("local-")) return;

    setIsLoadingMessages(true);
    const response = await fetch(`/api/workforce/${agentId}/threads/${threadId}`);
    const data = await response.json();
    
    // Convert to UIMessage format
    const uiMessages = data.messages.map((msg) => ({
      id: msg.id,
      role: msg.role,
      parts: [{ type: "text", text: msg.content }],
    }));
    
    setMessages(uiMessages);
    setIsLoadingMessages(false);
  }
  loadThreadMessages();
}, [threadId, agentId, setMessages]);

// thread-service.ts - Extract text from complex message formats
function extractMessageContent(content: unknown): string {
  // Simple string
  if (typeof content === "string") return content;

  // Array of content parts (AI SDK format)
  if (Array.isArray(content)) {
    return content
      .filter((part) => part.type === "text")
      .map((part) => part.text)
      .join("\n");
  }

  // Object with parts array (messagesV2 format)
  if (typeof content === "object" && content !== null) {
    if ("parts" in content && Array.isArray(content.parts)) {
      return content.parts
        .filter((part) => part.type === "text")
        .map((part) => part.text)
        .join("\n");
    }
    if ("content" in content) return content.content;
    if ("text" in content) return content.text;
  }

  return String(content);
}
```

---

### Phase 9.1f: Semantic Recall (Optional, Future)

**Goal:** Agent can find relevant past messages using semantic similarity.

#### File Impact Analysis

| File | Change | Priority |
|------|--------|----------|
| `app/api/workforce/[agentId]/chat/services/memory.ts` | Add vector store, embedder, semanticRecall config | P0 |
| `package.json` | Add embedding model package (if using OpenAI) | P0 |

#### Configuration

```typescript
// app/api/workforce/[agentId]/chat/services/memory.ts (updated for semantic recall)

import { openai } from "@ai-sdk/openai";

export function getAgentMemory(agentId: string): Memory {
  return new Memory({
    storage: new LibSQLStore({ 
      url: `file:./_tables/agents/${agentId}/memory.db` 
    }),
    vector: new LibSQLStore({ 
      url: `file:./_tables/agents/${agentId}/vectors.db`  // Separate for vectors
    }),
    embedder: openai.embedding("text-embedding-3-small"),
    options: {
      lastMessages: 10,
      semanticRecall: {
        topK: 3,
        messageRange: 2,
        scope: 'resource',  // Search across all user's threads
      },
      workingMemory: {
        enabled: true,
        scope: 'resource',
        schema: workingMemorySchema,
      },
    },
  });
}
```

#### Acceptance Criteria for Phase

- [ ] AC36: Messages embedded in vector DB
- [ ] AC37: Agent retrieves relevant past messages
- [ ] AC38: Semantic search respects user scope

#### Testing

1. Have conversation about "onboarding"
2. Start new conversation, ask "what did we discuss about onboarding?"
3. Agent recalls relevant context from old thread

---

## 6. Data Model

### Threads Table

| Column | Type | Description |
|--------|------|-------------|
| id | string | Unique thread ID |
| resourceId | string | User ID (from Clerk) |
| title | string | Thread title (auto-generated or user-set) |
| createdAt | timestamp | When thread was created |
| updatedAt | timestamp | Last message timestamp |
| metadata | json | Additional data |

### Messages Table

| Column | Type | Description |
|--------|------|-------------|
| id | string | Unique message ID |
| threadId | string | FK to thread |
| role | enum | 'user' | 'assistant' | 'system' | 'tool' |
| content | text | Message content |
| createdAt | timestamp | When sent |
| toolCallIds | json | Tool call references (if applicable) |

### Working Memory Table

| Column | Type | Description |
|--------|------|-------------|
| id | string | Unique ID |
| resourceId | string | User ID |
| threadId | string | Thread ID (if thread-scoped) |
| content | json | The actual working memory data |
| updatedAt | timestamp | Last update |

---

## 7. Design Decisions (Resolved via Mockups)

| Question | Decision | Rationale |
|----------|----------|-----------|
| Thread Titles | Auto-generate + user can rename | Mockup shows "Rename" button in header |
| Working Memory Visibility | Read-only with "Clear all" option | Mockup shows view-only with clear action |
| Semantic Recall Scope | Cross-thread per user (`scope: 'resource'`) | Agent should recall from all past conversations |
| Agent-Specific Memory | Per-agent (separate `memory.db`) | Each agent in `_tables/agents/[id]/` folder |

---

## 8. Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| LibSQL doesn't meet needs | Medium | Can migrate to PostgreSQL later |
| Working memory becomes stale | Low | Add "clear memory" option |
| Storage grows too large | Low | Add retention policy later |
| Embedding costs (semantic recall) | Medium | Make Phase 9.1d optional |

---

## 9. References

- [Mastra Memory Overview](https://mastra.ai/docs/memory/overview)
- [Mastra LibSQL Storage](https://mastra.ai/docs/memory/storage/libsql)
- [Task 9: Mastra Migration](/_docs/_tasks/9-mastra-migration.md)
- [Clerk Authentication](/_docs/_diary/16-ClerkAuthenticationIntegration.md)

---

## 10. Appendix: LibSQL Storage Details

### What Files Does LibSQL Create?

LibSQL creates **SQLite database files**:

```
_tables/agents/mira-patel/
  memory.db           # Main database file (your data)
  memory.db-shm       # Shared memory file (temporary)
  memory.db-wal       # Write-ahead log (temporary)
```

### Understanding SQLite Temporary Files

| File | Purpose | Behavior |
|------|---------|----------|
| `memory.db` | Your actual data | Keep this! |
| `memory.db-wal` | Write-Ahead Log - buffers writes before merging | Created on open, merged on checkpoint |
| `memory.db-shm` | Shared Memory - coordinates concurrent access | Only exists while DB is active |

**You only need to care about `memory.db`**. The others are automatically created when the database is opened and cleaned up when it closes properly.

### Per-Agent Database Pattern (Chosen)

```
_tables/
  agents/
    mira-patel/
      config.ts       # Agent configuration
      memory.db       # Mira's conversations & memory
    alex-kim/
      config.ts
      memory.db       # Alex's conversations & memory
```

**Benefits:**
- Clean organizational pattern matching existing `_tables` structure
- Each agent's data is isolated
- Easy to backup/delete individual agent data
- Already ignored by `.gitignore`

**Trade-off:**
- Memory instance created per-request (minimal overhead)
- Database file created on first conversation with each agent

