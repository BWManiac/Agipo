# Task 15.3a: Workflow JSON Schema Design

**Status:** Draft  
**Date:** December 2025  
**Parent:** `15.3-workflow-implementation.md`

---

## Purpose

This document defines the `workflow.json` schema that stores visual editor state, and the `workflow.ts` structure that gets generated for Mastra execution.

**Key Insight:** The workflow.json is the **single source of truth** for both list view and canvas view. Transpilation to workflow.ts is **deterministic** - same JSON always produces same TypeScript.

---

## 1. File Relationship

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Visual Editor (React)                          │
│  - Canvas view (ReactFlow nodes/edges)                             │
│  - List view (sequential steps)                                    │
│  - Both views read/write the SAME state                            │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              │ save
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     workflow.json                                   │
│  - Editor state (positions, UI metadata)                           │
│  - Step definitions (id, type, schemas)                            │
│  - Data mappings (field references between steps)                  │
│  - Control flow (execution order, branches, parallels)             │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              │ transpile (deterministic)
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     workflow.ts                                     │
│  - Generated Mastra code                                           │
│  - createStep() for each step                                      │
│  - .map() for each data mapping                                    │
│  - .then(), .parallel(), .branch() for control flow               │
│  - Executable by Mastra runtime                                    │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. workflow.json Schema

### 2.1 TypeScript Type Definition

```typescript
// app/api/workflows/services/types.ts

import { z } from "zod";

/**
 * Complete workflow definition stored in workflow.json
 */
export interface WorkflowDefinition {
  // === Identity ===
  id: string;                        // Unique identifier (kebab-case)
  name: string;                      // Display name
  description: string;               // Human-readable description
  
  // === Schemas (JSON Schema format) ===
  inputSchema: JSONSchema;           // What the workflow accepts as input
  outputSchema: JSONSchema;          // What the workflow returns
  
  // === Steps ===
  steps: WorkflowStep[];             // Ordered list of steps
  
  // === Data Mappings ===
  mappings: DataMapping[];           // How data flows between steps
  
  // === Control Flow ===
  controlFlow: ControlFlowConfig;    // Execution order and branching
  
  // === Connection Requirements ===
  connections: {
    [toolkitSlug: string]: string | null;  // connectionId or null (inherit from agent)
  };
  
  // === Table Requirements ===
  tableRequirements: TableRequirement[];   // Tables this workflow needs
  tables: {
    [tableKey: string]: string | null;     // tableId or null (set at assignment)
  };
  
  // === Runtime Configuration ===
  runtimeInputs: RuntimeInputConfig[];    // User-defined inputs
  configs: WorkflowConfig[];              // User-defined configs
  
  // === Metadata ===
  createdAt: string;                 // ISO 8601
  lastModified: string;              // ISO 8601
  createdBy: string;                 // User ID
  published: boolean;                // Whether shareable
}

/**
 * A single step in the workflow
 */
export interface WorkflowStep {
  // === Identity ===
  id: string;                        // Unique within workflow
  
  // === Type ===
  type: "composio" | "custom" | "control" | "query_table" | "write_table";
  
  // === Position (for both views) ===
  position: { x: number; y: number }; // Canvas coordinates
  listIndex: number;                  // List view order
  
  // === Composio Tool (when type === "composio") ===
  toolId?: string;                   // e.g., "FIRECRAWL_SCRAPE"
  toolkitSlug?: string;              // e.g., "firecrawl"
  toolkitName?: string;              // e.g., "Firecrawl"
  toolkitLogo?: string;              // URL
  
  // === Custom Code (when type === "custom") ===
  code?: string;                     // JavaScript/TypeScript
  
  // === Control Flow (when type === "control") ===
  controlType?: "branch" | "parallel" | "loop" | "wait";
  controlConfig?: BranchConfig | ParallelConfig | LoopConfig;
  
  // === Table Operations (when type === "query_table" or "write_table") ===
  tableRef?: string;                 // Reference to table config: "output_table"
  tableConfig?: QueryTableConfig | WriteTableConfig;
  
  // === Schemas (cached from Composio or user-defined) ===
  inputSchema: JSONSchema;
  outputSchema: JSONSchema;
  
  // === UI State ===
  name: string;                      // Display name
  description?: string;              // Optional description
  collapsed?: boolean;               // UI state for list view
}

/**
 * Query Table node configuration
 */
export interface QueryTableConfig {
  filter?: {
    column: string;
    operator: "eq" | "neq" | "gt" | "lt" | "contains";
    value: string | number | boolean;  // Can be literal or {{reference}}
  };
  sort?: {
    column: string;
    descending?: boolean;
  };
  limit?: number;
}

/**
 * Write to Table node configuration
 */
export interface WriteTableConfig {
  mode: "insert" | "upsert";          // Insert new or update if exists
  upsertKey?: string;                 // Column to match for upsert
}

/**
 * Data mapping between two steps
 */
export interface DataMapping {
  id: string;                        // Unique mapping ID
  sourceStepId: string;              // Step providing data
  targetStepId: string;              // Step receiving data
  
  fieldMappings: FieldMapping[];     // Individual field mappings
}

export interface FieldMapping {
  sourcePath: string;                // e.g., "data.title" or "result.user.email"
  targetField: string;               // e.g., "jobTitle"
  
  // === Type Info (for validation) ===
  sourceType?: string;               // e.g., "string", "number"
  targetType?: string;               // e.g., "string", "number"
  typeMatch?: "exact" | "coercible" | "incompatible";
}

/**
 * Control flow configuration
 */
export interface ControlFlowConfig {
  type: "sequential" | "parallel" | "branched" | "mixed";
  
  // For sequential (simple case)
  order?: string[];                  // Step IDs in execution order
  
  // For parallel
  parallelGroups?: string[][];       // Groups of step IDs that run in parallel
  
  // For branched
  branches?: BranchConfig[];
}

export interface BranchConfig {
  conditionExpression: string;       // JS expression: "inputData.priority === 'high'"
  stepId: string;                    // Step to execute if condition is true
}

export interface ParallelConfig {
  stepIds: string[];                 // Steps to run in parallel
  mergeStrategy?: "all" | "first";   // How to combine results
}

export interface LoopConfig {
  type: "while" | "until" | "foreach";
  conditionExpression?: string;      // For while/until
  iterableField?: string;            // For foreach
  concurrency?: number;              // For foreach
}

/**
 * Runtime input configuration
 */
export interface RuntimeInputConfig {
  key: string;                       // e.g., "jobUrl"
  type: "string" | "number" | "boolean" | "array" | "object";
  label: string;                     // Display label
  description?: string;
  required: boolean;
  default?: unknown;
  validation?: {
    format?: "email" | "url" | "date";
    min?: number;
    max?: number;
    pattern?: string;
  };
}

/**
 * Workflow configuration
 */
export interface WorkflowConfig {
  key: string;                       // e.g., "resumeTemplate"
  type: "text" | "number" | "boolean" | "select";
  label: string;
  description?: string;
  required: boolean;
  default?: unknown;
  options?: string[];                // For select type
}

/**
 * Table requirement configuration
 */
export interface TableRequirement {
  key: string;                       // Internal reference: "output_table"
  purpose: "read" | "write" | "readwrite";
  description: string;               // "Table to store scraped job listings"
  
  requiredColumns: ColumnRequirement[];
  optionalColumns?: ColumnRequirement[];
  
  canAutoCreate: boolean;            // Show "Create new table" option
  autoCreateName?: string;           // Suggested name for new table
}

export interface ColumnRequirement {
  key: string;                       // How workflow references it: "job_title"
  suggestedName: string;             // Suggested column name: "Job Title"
  type: "text" | "number" | "date" | "boolean" | "select";
  required: boolean;
}

/**
 * Table binding (set at assignment time)
 */
export interface TableBinding {
  tableId: string;                   // ID of the bound table
  columnMapping: {
    [workflowColumn: string]: string; // workflow column → table column
  };
}

/**
 * JSON Schema subset we support
 */
export interface JSONSchema {
  type: "object" | "array" | "string" | "number" | "boolean" | "integer";
  properties?: {
    [key: string]: JSONSchema & {
      description?: string;
    };
  };
  items?: JSONSchema;
  required?: string[];
  format?: string;
  enum?: unknown[];
}
```

### 2.2 Example workflow.json

```json
{
  "id": "job-application-helper",
  "name": "Job Application Helper",
  "description": "Scrapes job listings and generates tailored resumes",
  
  "inputSchema": {
    "type": "object",
    "properties": {
      "jobUrl": { 
        "type": "string", 
        "format": "uri",
        "description": "URL of the job listing to scrape"
      },
      "baseResume": { 
        "type": "string",
        "description": "Your base resume text to tailor"
      }
    },
    "required": ["jobUrl", "baseResume"]
  },
  
  "outputSchema": {
    "type": "object",
    "properties": {
      "tailoredResume": { 
        "type": "string",
        "description": "Resume tailored to the job listing"
      }
    }
  },
  
  "steps": [
    {
      "id": "scrape-job",
      "type": "composio",
      "toolId": "FIRECRAWL_SCRAPE",
      "toolkitSlug": "firecrawl",
      "toolkitName": "Firecrawl",
      "toolkitLogo": "https://...",
      "position": { "x": 100, "y": 200 },
      "listIndex": 0,
      "name": "Scrape Job Listing",
      "description": "Extract job details from the URL",
      "inputSchema": {
        "type": "object",
        "properties": {
          "url": { "type": "string", "format": "uri" }
        },
        "required": ["url"]
      },
      "outputSchema": {
        "type": "object",
        "properties": {
          "data": { "type": "object" },
          "error": { "type": "string" },
          "successful": { "type": "boolean" }
        }
      }
    },
    {
      "id": "generate-resume",
      "type": "custom",
      "code": "async function execute({ inputData }) {\n  // Use LLM to tailor resume\n  const tailored = await generateTailoredResume(inputData);\n  return { tailoredResume: tailored };\n}",
      "position": { "x": 400, "y": 200 },
      "listIndex": 1,
      "name": "Generate Tailored Resume",
      "description": "Use AI to tailor resume to job requirements",
      "inputSchema": {
        "type": "object",
        "properties": {
          "jobTitle": { "type": "string" },
          "companyName": { "type": "string" },
          "requirements": { "type": "array", "items": { "type": "string" } },
          "baseResume": { "type": "string" }
        },
        "required": ["jobTitle", "companyName", "requirements", "baseResume"]
      },
      "outputSchema": {
        "type": "object",
        "properties": {
          "tailoredResume": { "type": "string" }
        }
      }
    }
  ],
  
  "mappings": [
    {
      "id": "mapping-scrape-to-generate",
      "sourceStepId": "scrape-job",
      "targetStepId": "generate-resume",
      "fieldMappings": [
        { "sourcePath": "data.title", "targetField": "jobTitle", "typeMatch": "exact" },
        { "sourcePath": "data.company", "targetField": "companyName", "typeMatch": "exact" },
        { "sourcePath": "data.requirements", "targetField": "requirements", "typeMatch": "exact" }
      ]
    },
    {
      "id": "mapping-input-to-scrape",
      "sourceStepId": "__input__",
      "targetStepId": "scrape-job",
      "fieldMappings": [
        { "sourcePath": "jobUrl", "targetField": "url", "typeMatch": "exact" }
      ]
    },
    {
      "id": "mapping-input-to-generate",
      "sourceStepId": "__input__",
      "targetStepId": "generate-resume",
      "fieldMappings": [
        { "sourcePath": "baseResume", "targetField": "baseResume", "typeMatch": "exact" }
      ]
    }
  ],
  
  "controlFlow": {
    "type": "sequential",
    "order": ["scrape-job", "generate-resume"]
  },
  
  "connections": {
    "firecrawl": null
  },
  
  "tableRequirements": [
    {
      "key": "job_archive",
      "purpose": "write",
      "description": "Table to archive scraped job listings",
      "requiredColumns": [
        { "key": "job_title", "suggestedName": "Job Title", "type": "text", "required": true },
        { "key": "company", "suggestedName": "Company", "type": "text", "required": true },
        { "key": "url", "suggestedName": "URL", "type": "text", "required": true },
        { "key": "scraped_at", "suggestedName": "Scraped At", "type": "date", "required": true }
      ],
      "canAutoCreate": true,
      "autoCreateName": "Job Listings"
    }
  ],
  
  "tables": {
    "job_archive": null
  },
  
  "runtimeInputs": [
    {
      "key": "jobUrl",
      "type": "string",
      "label": "Job Listing URL",
      "description": "The URL of the job listing to scrape",
      "required": true,
      "validation": { "format": "url" }
    },
    {
      "key": "baseResume",
      "type": "string",
      "label": "Base Resume",
      "description": "Your resume text that will be tailored",
      "required": true
    }
  ],
  
  "configs": [
    {
      "key": "resumeStyle",
      "type": "select",
      "label": "Resume Style",
      "options": ["modern", "classic", "creative"],
      "default": "modern",
      "required": false
    }
  ],
  
  "createdAt": "2025-12-06T15:00:00Z",
  "lastModified": "2025-12-06T16:30:00Z",
  "createdBy": "user-123",
  "published": false
}
```

---

## 3. Generated workflow.ts Structure

### 3.1 Template

```typescript
// _tables/workflows/[workflowId]/workflow.ts
// Auto-generated from workflow.json - DO NOT EDIT DIRECTLY

import { createWorkflow, createStep } from "@mastra/core";
import { z } from "zod";
import { getComposioClient } from "@/app/api/connections/services/composio";

// ============================================================================
// Input/Output Schemas
// ============================================================================

const inputSchema = z.object({
  // Generated from workflow.inputSchema
});

const outputSchema = z.object({
  // Generated from workflow.outputSchema
});

// ============================================================================
// Step Definitions
// ============================================================================

// Generated for each step in workflow.steps

const [stepId]Step = createStep({
  id: "[stepId]",
  description: "[step.description]",
  inputSchema: z.object({ /* Generated from step.inputSchema */ }),
  outputSchema: z.object({ /* Generated from step.outputSchema */ }),
  execute: async ({ inputData, resourceId }) => {
    // For composio steps:
    const client = getComposioClient();
    const result = await client.tools.execute("[toolId]", {
      arguments: inputData,
      connected_account_id: "{{connectionId:[toolkitSlug]}}",
      user_id: resourceId,
    });
    if (!result.successful) {
      throw new Error(result.error || "Tool execution failed");
    }
    return result.data;
    
    // For custom steps:
    // User-provided code
  },
});

// ============================================================================
// Workflow Composition
// ============================================================================

export const [workflowId]Workflow = createWorkflow({
  id: "[workflowId]",
  description: "[workflow.description]",
  inputSchema,
  outputSchema,
})
  .then([firstStep]Step)
  .map({
    // Generated from mappings where targetStepId === nextStep
    [targetField]: { step: [sourceStep]Step, path: "[sourcePath]" },
    // For workflow input references:
    [targetField]: { initData: [workflowId]Workflow, path: "[sourcePath]" },
  })
  .then([nextStep]Step)
  // ... more steps
  .commit();

// ============================================================================
// Export for execution
// ============================================================================

export async function executeWorkflow(
  inputs: z.infer<typeof inputSchema>,
  connectionIds: Record<string, string>,
  resourceId?: string
) {
  const run = await [workflowId]Workflow.createRunAsync({ resourceId });
  return run.start({ inputData: inputs });
}
```

### 3.2 Example Generated workflow.ts

```typescript
// _tables/workflows/job-application-helper/workflow.ts
// Auto-generated from workflow.json - DO NOT EDIT DIRECTLY

import { createWorkflow, createStep } from "@mastra/core";
import { z } from "zod";
import { getComposioClient } from "@/app/api/connections/services/composio";

// ============================================================================
// Input/Output Schemas
// ============================================================================

const inputSchema = z.object({
  jobUrl: z.string().url(),
  baseResume: z.string(),
});

const outputSchema = z.object({
  tailoredResume: z.string(),
});

// ============================================================================
// Step Definitions
// ============================================================================

const scrapeJobStep = createStep({
  id: "scrape-job",
  description: "Extract job details from the URL",
  inputSchema: z.object({
    url: z.string().url(),
  }),
  outputSchema: z.object({
    data: z.record(z.string(), z.any()),
    error: z.string().optional(),
    successful: z.boolean(),
  }),
  execute: async ({ inputData, resourceId }) => {
    const client = getComposioClient();
    const result = await client.tools.execute("FIRECRAWL_SCRAPE", {
      arguments: inputData,
      connected_account_id: "{{connectionId:firecrawl}}",
      user_id: resourceId,
    });
    if (!result.successful) {
      throw new Error(result.error || "Tool execution failed");
    }
    return result.data;
  },
});

const generateResumeStep = createStep({
  id: "generate-resume",
  description: "Use AI to tailor resume to job requirements",
  inputSchema: z.object({
    jobTitle: z.string(),
    companyName: z.string(),
    requirements: z.array(z.string()),
    baseResume: z.string(),
  }),
  outputSchema: z.object({
    tailoredResume: z.string(),
  }),
  execute: async ({ inputData }) => {
    // Custom code from user
    const tailored = await generateTailoredResume(inputData);
    return { tailoredResume: tailored };
  },
});

// ============================================================================
// Workflow Composition
// ============================================================================

export const jobApplicationHelperWorkflow = createWorkflow({
  id: "job-application-helper",
  description: "Scrapes job listings and generates tailored resumes",
  inputSchema,
  outputSchema,
})
  .then(scrapeJobStep)
  .map({
    jobTitle: { step: scrapeJobStep, path: "data.title" },
    companyName: { step: scrapeJobStep, path: "data.company" },
    requirements: { step: scrapeJobStep, path: "data.requirements" },
    baseResume: { initData: jobApplicationHelperWorkflow, path: "baseResume" },
  })
  .then(generateResumeStep)
  .commit();

// ============================================================================
// Export for execution
// ============================================================================

export async function executeWorkflow(
  inputs: z.infer<typeof inputSchema>,
  connectionIds: Record<string, string>,
  resourceId?: string
) {
  const run = await jobApplicationHelperWorkflow.createRunAsync({ resourceId });
  return run.start({ inputData: inputs });
}
```

---

## 4. View Mapping

### 4.1 How List View Reads workflow.json

```typescript
// List view sorts by listIndex
const orderedSteps = workflow.steps.sort((a, b) => a.listIndex - b.listIndex);

// For each step, show:
// - step.name
// - step.type (icon)
// - step.inputSchema (collapsed by default)
// - Data source indicators from mappings where targetStepId === step.id
```

### 4.2 How Canvas View Reads workflow.json

```typescript
// Canvas uses position for node placement
const nodes = workflow.steps.map(step => ({
  id: step.id,
  type: step.type === 'composio' ? 'toolNode' : 'customNode',
  position: step.position,
  data: step,
}));

// Edges derived from mappings
const edges = workflow.mappings
  .filter(m => m.sourceStepId !== '__input__')
  .map(mapping => ({
    id: mapping.id,
    source: mapping.sourceStepId,
    target: mapping.targetStepId,
    data: mapping,
  }));
```

### 4.3 Syncing Between Views

```typescript
// When list view reorders
function reorderSteps(stepIds: string[]) {
  setWorkflow(prev => ({
    ...prev,
    steps: prev.steps.map(step => ({
      ...step,
      listIndex: stepIds.indexOf(step.id),
    })),
    controlFlow: {
      ...prev.controlFlow,
      order: stepIds,
    },
  }));
}

// When canvas view moves node
function moveNode(stepId: string, position: { x: number; y: number }) {
  setWorkflow(prev => ({
    ...prev,
    steps: prev.steps.map(step =>
      step.id === stepId ? { ...step, position } : step
    ),
  }));
}
```

---

## 5. Transpilation Rules

### 5.1 JSON Schema → Zod Schema

```typescript
function jsonSchemaToZod(schema: JSONSchema): string {
  switch (schema.type) {
    case 'string':
      let s = 'z.string()';
      if (schema.format === 'email') s += '.email()';
      if (schema.format === 'url') s += '.url()';
      return s;
    
    case 'number':
      return 'z.number()';
    
    case 'integer':
      return 'z.number().int()';
    
    case 'boolean':
      return 'z.boolean()';
    
    case 'array':
      return `z.array(${jsonSchemaToZod(schema.items!)})`;
    
    case 'object':
      if (!schema.properties) return 'z.record(z.string(), z.any())';
      
      const props = Object.entries(schema.properties)
        .map(([key, value]) => {
          const zodType = jsonSchemaToZod(value);
          const isRequired = schema.required?.includes(key);
          return `${key}: ${zodType}${isRequired ? '' : '.optional()'}`;
        })
        .join(',\n  ');
      
      return `z.object({\n  ${props}\n})`;
  }
}
```

### 5.2 Mappings → .map() Call

```typescript
function generateMapCall(
  mappings: DataMapping[],
  targetStepId: string,
  workflowId: string
): string {
  const relevantMappings = mappings.filter(m => m.targetStepId === targetStepId);
  
  if (relevantMappings.length === 0) return '';
  
  const mapEntries = relevantMappings.flatMap(mapping =>
    mapping.fieldMappings.map(fm => {
      if (mapping.sourceStepId === '__input__') {
        return `${fm.targetField}: { initData: ${workflowId}Workflow, path: "${fm.sourcePath}" }`;
      }
      return `${fm.targetField}: { step: ${mapping.sourceStepId}Step, path: "${fm.sourcePath}" }`;
    })
  );
  
  return `.map({\n    ${mapEntries.join(',\n    ')}\n  })`;
}
```

### 5.3 Control Flow → Chained Methods

```typescript
function generateWorkflowChain(workflow: WorkflowDefinition): string {
  const { controlFlow, steps, mappings } = workflow;
  
  let chain = '';
  
  if (controlFlow.type === 'sequential') {
    for (const stepId of controlFlow.order!) {
      chain += `\n  .then(${stepId}Step)`;
      
      // Check if next step needs mapping
      const nextStepId = controlFlow.order![controlFlow.order!.indexOf(stepId) + 1];
      if (nextStepId) {
        const mapCall = generateMapCall(mappings, nextStepId, workflow.id);
        if (mapCall) chain += `\n  ${mapCall}`;
      }
    }
  } else if (controlFlow.type === 'parallel') {
    // Handle parallel groups
    for (const group of controlFlow.parallelGroups!) {
      if (group.length === 1) {
        chain += `\n  .then(${group[0]}Step)`;
      } else {
        const stepRefs = group.map(id => `${id}Step`).join(', ');
        chain += `\n  .parallel([${stepRefs}])`;
      }
    }
  } else if (controlFlow.type === 'branched') {
    // Handle branches
    const branchEntries = controlFlow.branches!.map(b =>
      `[async ({ inputData }) => ${b.conditionExpression}, ${b.stepId}Step]`
    ).join(',\n    ');
    chain += `\n  .branch([\n    ${branchEntries}\n  ])`;
  }
  
  chain += '\n  .commit();';
  return chain;
}
```

---

## 6. Special Mappings

### 6.1 Workflow Input (`__input__`)

When `sourceStepId === '__input__'`, the mapping references the workflow's input data:

```typescript
// In workflow.json
{
  "sourceStepId": "__input__",
  "targetStepId": "generate-resume",
  "fieldMappings": [
    { "sourcePath": "baseResume", "targetField": "baseResume" }
  ]
}

// Generates:
.map({
  baseResume: { initData: jobApplicationHelperWorkflow, path: "baseResume" },
})
```

### 6.2 Workflow Output (`__output__`)

When `targetStepId === '__output__'`, the mapping defines the workflow's final output:

```typescript
// In workflow.json
{
  "sourceStepId": "generate-resume",
  "targetStepId": "__output__",
  "fieldMappings": [
    { "sourcePath": "tailoredResume", "targetField": "tailoredResume" }
  ]
}

// The last step's output becomes the workflow output
// (handled automatically by Mastra when outputSchema matches)
```

---

## 7. Connection Placeholder Resolution

The generated code uses placeholders like `{{connectionId:firecrawl}}` that get resolved at execution time:

```typescript
// Generated code has:
connected_account_id: "{{connectionId:firecrawl}}",

// At execution time, resolve placeholders:
function resolveConnectionPlaceholders(
  code: string,
  connectionIds: Record<string, string>
): string {
  return code.replace(/\{\{connectionId:(\w+)\}\}/g, (_, toolkit) => {
    const connectionId = connectionIds[toolkit];
    if (!connectionId) {
      throw new Error(`Missing connection for toolkit: ${toolkit}`);
    }
    return connectionId;
  });
}
```

---

## 8. Validation

### 8.1 Schema Validation

```typescript
import Ajv from "ajv";

const ajv = new Ajv();

function validateWorkflow(workflow: WorkflowDefinition): ValidationResult {
  const errors: string[] = [];
  
  // 1. Validate all steps have unique IDs
  const stepIds = workflow.steps.map(s => s.id);
  if (new Set(stepIds).size !== stepIds.length) {
    errors.push("Duplicate step IDs found");
  }
  
  // 2. Validate mappings reference valid steps
  for (const mapping of workflow.mappings) {
    if (mapping.sourceStepId !== '__input__' && 
        !stepIds.includes(mapping.sourceStepId)) {
      errors.push(`Mapping references unknown step: ${mapping.sourceStepId}`);
    }
    if (mapping.targetStepId !== '__output__' && 
        !stepIds.includes(mapping.targetStepId)) {
      errors.push(`Mapping references unknown step: ${mapping.targetStepId}`);
    }
  }
  
  // 3. Validate control flow references valid steps
  if (workflow.controlFlow.order) {
    for (const stepId of workflow.controlFlow.order) {
      if (!stepIds.includes(stepId)) {
        errors.push(`Control flow references unknown step: ${stepId}`);
      }
    }
  }
  
  // 4. Validate required connections
  for (const step of workflow.steps) {
    if (step.type === 'composio' && step.toolkitSlug) {
      if (!(step.toolkitSlug in workflow.connections)) {
        errors.push(`Step ${step.id} requires ${step.toolkitSlug} connection`);
      }
    }
  }
  
  return {
    valid: errors.length === 0,
    errors,
  };
}
```

---

## 9. References

- **Research:** `15.2-workflow-research.md` Part 6: workflow.json Schema
- **Mastra Primitives:** `_docs/Engineering/Integrations/API Docs/Mastra/Workflow-Primitives.md`
- **Existing Pattern:** `_tables/tools/hohoho/workflow.json`
- **Composio Schema:** `outputParameters` from `client.tools.retrieve()`

