# Task 15.5: Workflows F Transpilation & Agent Integration â€” Research Log

**Status:** âœ… Complete  
**Date:** December 7, 2025  
**Parent Task:** [16-workflows-f](./16-workflows-f/)

---

## How to Use This Document

This is a **research log** for discovering facts about:
1. **Mastra Workflow API** â€” How to generate valid workflow.ts files
2. **Composio Tool Execution** â€” How to call tools within Mastra steps
3. **Agent Integration** â€” How to assign workflows as agent capabilities

**Each research question has:**
1. **The Question** â€” What we need to find out
2. **Why It Matters** â€” Which transpilation requirement this unlocks
3. **Answer** â€” What we discovered
4. **Primitive** â€” The exact function/method we'll use
5. **Source** â€” Where we found the answer

**Philosophy:** Mastra's API is our target. We discover what it provides and generate code that conforms to it.

**Status Key:** â“ Not Researched | ðŸ” In Progress | âœ… Answered | âš ï¸ Blocked

---

## Quick Reference

| Question | Unlocks | Status |
|----------|---------|--------|
| [RQ-1: createStep signature](#rq-1-createstep-signature) | Step generation | âœ… |
| [RQ-2: .map() data mapping](#rq-2-map-data-mapping) | Data flow | âœ… |
| [RQ-3: .branch() conditions](#rq-3-branch-conditions) | Conditional logic | âœ… |
| [RQ-4: .parallel() execution](#rq-4-parallel-execution) | Parallel steps | âœ… |
| [RQ-5: Loop primitives](#rq-5-loop-primitives) | Loops & iteration | âœ… |
| [RQ-6: runtimeContext for connections](#rq-6-runtimecontext-for-connections) | Composio auth | âœ… |
| [RQ-7: Composio tool in step](#rq-7-composio-tool-in-step) | Tool execution | âœ… |
| [RQ-8: Workflow registration](#rq-8-workflow-registration) | Agent availability | âœ… |
| [RQ-9: JSON Schema â†’ Zod](#rq-9-json-schema-to-zod) | Schema conversion | âœ… |
| [RQ-10: Nested workflows](#rq-10-nested-workflows) | Container steps | âœ… |
| [RQ-11: Pre-save validation](#rq-11-pre-save-validation) | Error prevention | âœ… |
| [RQ-12: workflowBindings schema](#rq-12-workflowbindings-schema) | Agent config | âœ… |
| [RQ-13: Connection passing at runtime](#rq-13-connection-passing-at-runtime) | Runtime binding | âœ… |
| [RQ-14: Capabilities UI](#rq-14-capabilities-ui) | Workflow assignment UX | âœ… |
| [RQ-15: File structure & imports](#rq-15-file-structure-and-imports) | Dynamic loading | âœ… |

---

## Part 1: Mastra Workflow API Research

### RQ-1: createStep Signature

**Why It Matters:** Every `WorkflowStep` in our editor becomes a `createStep()` call. This is the core primitive for transpilation.

**Status:** âœ… Answered

**Question:** What is the exact TypeScript signature of `createStep()` and what fields are required vs optional?

**Answer:**
```typescript
const step = createStep({
  id: "step-id",                              // Required: unique identifier
  inputSchema: z.object({ ... }),             // Required: Zod schema
  outputSchema: z.object({ ... }),            // Required: Zod schema
  execute: async ({ inputData, runtimeContext, state, setState }) => {
    // Business logic
    return { ...output };
  },
});
```

**Primitive Discovered:**
- Function/Method: `createStep`
- Required fields: `id`, `inputSchema`, `outputSchema`, `execute`
- Optional fields: `stateSchema` (for workflow state)
- Execute receives: `inputData`, `runtimeContext`, `state`, `setState`

**Implementation Note:** The `id` field is critical â€” it's used as the key in parallel/branch outputs. We should use `step.id` from our `WorkflowStep`.

**Source:** https://mastra.ai/docs/workflows/overview, https://mastra.ai/docs/workflows/control-flow

---

### RQ-2: .map() Data Mapping

**Why It Matters:** Our `mappings` object defines how data flows between steps. We need to generate `.map()` calls.

**Status:** âœ… Answered

**Question:** How does `.map()` work in Mastra? What is the syntax for mapping previous step outputs to next step inputs?

**Answer:**
```typescript
// Basic mapping
.then(step1)
.map(async ({ inputData }) => {
  const { foo } = inputData;
  return {
    bar: `new ${foo}`,
  };
})
.then(step2)

// With helper functions
.map(async ({ inputData, getStepResult, getInitData }) => {
  const step1Result = getStepResult("step-1");  // Access any previous step
  const initData = getInitData();              // Access workflow initial input
  return { ... };
})

// For parallel/branch outputs
.parallel([step1, step2])
.map(async ({ inputData }) => {
  return {
    combined: `${inputData["step-1"].value} - ${inputData["step-2"].value}`
  };
})
```

**Primitive Discovered:**
- Function/Method: `.map()`
- Signature: `.map(async ({ inputData, getStepResult, getInitData }) => newShape)`
- Helper functions: `getStepResult(stepId)`, `getInitData()`, `mapVariable()`
- Returns: Object matching next step's inputSchema

**Implementation Note:** We can use `.map()` after any step to transform data. For parallel/branch, inputs are keyed by step id.

**Source:** https://mastra.ai/docs/workflows/control-flow#input-data-mapping

---

### RQ-3: .branch() Conditions

**Why It Matters:** Our `BranchConfig` has conditions and targets. Need to generate `.branch()` with proper condition functions.

**Status:** âœ… Answered

**Question:** What is the exact syntax for `.branch()`? How are conditions defined? What types do they return?

**Answer:**
```typescript
.branch([
  [async ({ inputData }) => inputData.value > 10, highValueStep],
  [async ({ inputData }) => inputData.value <= 10, lowValueStep]
])

// After branch, next step receives output keyed by executed step's id:
// { "high-value-step": { result: "..." } }  OR  { "low-value-step": { result: "..." } }

// Next step inputSchema should use optional fields:
inputSchema: z.object({
  "high-value-step": z.object({ result: z.string() }).optional(),
  "low-value-step": z.object({ result: z.string() }).optional()
})
```

**Primitive Discovered:**
- Function/Method: `.branch()`
- Signature: `.branch([ [condition, step], [condition, step], ... ])`
- Condition: `async ({ inputData }) => boolean`
- Evaluation: First condition that returns `true` wins
- Output: `{ [executedStepId]: stepOutput }` (only one key)
- All branch steps MUST have same inputSchema and outputSchema

**Implementation Note:** Our `BranchConfig.conditions` array maps directly to this. Need to generate condition functions from our stored expressions.

**Source:** https://mastra.ai/docs/workflows/control-flow#conditional-logic-with-branch

---

### RQ-4: .parallel() Execution

**Why It Matters:** Our `ParallelConfig` has branches that should run concurrently. Need to generate `.parallel()`.

**Status:** âœ… Answered

**Question:** How does `.parallel()` work? Does it wait for all branches? How are failures handled?

**Answer:**
```typescript
.parallel([step1, step2])
.then(step3)  // step3 receives combined outputs

// step3's inputSchema must match parallel output structure:
inputSchema: z.object({
  "step-1": z.object({ formatted: z.string() }),
  "step-2": z.object({ emphasized: z.string() })
})

// Inside step3's execute:
execute: async ({ inputData }) => {
  const { formatted } = inputData["step-1"];
  const { emphasized } = inputData["step-2"];
  return { combined: `${formatted} | ${emphasized}` };
}
```

**Primitive Discovered:**
- Function/Method: `.parallel()`
- Signature: `.parallel([step1, step2, ...])`
- Output: `{ [stepId]: stepOutput, [stepId]: stepOutput, ... }` (all keys present)
- Behavior: All steps execute simultaneously, waits for all to complete
- No fail-fast option documented; likely fails on first error

**Implementation Note:** Unlike branch (one key), parallel has ALL step outputs keyed by id. Our `ParallelConfig.branches` maps to array of steps.

**Source:** https://mastra.ai/docs/workflows/control-flow#simultaneous-steps-with-parallel

---

### RQ-5: Loop Primitives

**Why It Matters:** Our `LoopConfig` and `ForEachConfig` map to `.dountil()`, `.dowhile()`, `.foreach()`.

**Status:** âœ… Answered

**Question:** What are the signatures for loop primitives? How do conditions and iteration variables work?

**Answer:**
```typescript
// .dountil() - Run until condition is TRUE (stops when true)
.dountil(step, async ({ inputData: { number } }) => number > 10)

// .dowhile() - Run while condition is TRUE (stops when false)
.dowhile(step, async ({ inputData: { number } }) => number < 10)

// .foreach() - Iterate over array
// Input MUST be array type
inputSchema: z.array(z.string())
outputSchema: z.array(z.string())

.foreach(step1)  // step1 receives each item, not array

// With concurrency:
.foreach(step1, { concurrency: 4 })

// Loop management with iterationCount:
.dountil(step, async ({ inputData: { result, iterationCount } }) => {
  if (iterationCount >= 10) {
    throw new Error("Maximum iterations reached");
  }
  return result === "done";
})
```

**Primitive Discovered:**
- `.dountil(step, condition)` - loop until true
- `.dowhile(step, condition)` - loop while true  
- `.foreach(step, options?)` - iterate over array
- Condition: `async ({ inputData, iterationCount }) => boolean`
- ForEach options: `{ concurrency: number }` (default: 1)
- Step inside foreach receives single item, not array
- Workflow inputSchema for foreach must be array type

**Implementation Note:** Our `LoopConfig.type: "until" | "while"` maps to `.dountil()` vs `.dowhile()`. ForEach is separate.

**Source:** https://mastra.ai/docs/workflows/control-flow#looping-steps

---

### RQ-6: runtimeContext for Connections

**Why It Matters:** Composio tools need connection IDs. These are passed at runtime via `runtimeContext`.

**Status:** âœ… Answered

**Question:** How does `runtimeContext` work in Mastra steps? How do we access values from it?

**Answer:**
```typescript
// runtimeContext is passed to step execute function
const step = createStep({
  execute: async ({ inputData, runtimeContext }) => {
    // Access values from context
    const userTier = runtimeContext.get("user-tier");
    const connections = runtimeContext.get("connections");
    
    // Use in Composio tool call
    const connectionId = connections?.["gmail"];
    
    return { ... };
  }
});

// When running workflow, pass runtimeContext:
const run = await testWorkflow.createRunAsync({
  runtimeContext: new RuntimeContext({
    "user-tier": "enterprise",
    "connections": { gmail: "conn_abc123", slack: "conn_xyz789" }
  })
});
```

**Primitive Discovered:**
- Access pattern: `runtimeContext.get("key")`
- Available in: `execute({ inputData, runtimeContext, mastra, state, setState })`
- Can store: Any key-value pairs (connections, user info, etc.)
- Set at: Workflow run time via `createRunAsync()` or `createRun()`

**Implementation Note:** We'll pass connection bindings via runtimeContext when agent invokes workflow. The generated step code will use `runtimeContext.get("connections")` to get the appropriate connectionId for each toolkit.

**Source:** https://mastra.ai/docs/workflows/overview, https://mastra.ai/docs/workflows/agents-and-tools

---

### RQ-7: Composio Tool in Step

**Why It Matters:** When step.type === "composio", we need to generate code that executes the Composio tool.

**Status:** âœ… Answered

**Question:** What does a Composio tool execution look like inside a Mastra step execute function?

**Answer:**
```typescript
// Based on existing pattern in composio-tools.ts
const composioStep = createStep({
  id: "scrape-webpage",
  inputSchema: z.object({ url: z.string() }),
  outputSchema: z.object({ data: z.any(), successful: z.boolean() }),
  execute: async ({ inputData, runtimeContext }) => {
    // Get connection from runtimeContext (set by agent at workflow invocation)
    const connections = runtimeContext.get("connections") as Record<string, string>;
    const connectionId = connections?.["firecrawl"];
    
    // Get Composio client
    const client = getComposioClient();
    
    // Execute the tool
    const result = await client.tools.execute(
      "FIRECRAWL_SCRAPE",
      inputData,
      connectionId  // Pass the bound connection
    );
    
    if (!result.successful) {
      throw new Error(result.error || "Tool execution failed");
    }
    
    return {
      data: result.data,
      successful: true
    };
  }
});
```

**Primitive Discovered:**
- Client: `getComposioClient()` (existing helper)
- Execution: `client.tools.execute(toolId, input, connectionId)`
- Result shape: `{ data, successful, error? }`
- Connection binding: Via `runtimeContext.get("connections")`

**Implementation Note:** We have existing patterns in `app/api/tools/services/composio-tools.ts`. For transpilation, we need to generate this execute body with:
1. Tool ID from `step.toolId`
2. Toolkit slug for connection lookup from `step.toolkitSlug`
3. Input mapping from step's inputSchema

**Source:** Existing code in `app/api/tools/services/composio-tools.ts` (getConnectionToolExecutable)

---

## Part 2: Agent Integration Research

### RQ-8: Workflow Registration

**Why It Matters:** Generated workflows need to be registered so agents can access them.

**Status:** âœ… Answered (from existing codebase patterns)

**Question:** How are Mastra workflows registered and made available to agents? What's the import pattern?

**Answer:**
Based on existing patterns in our codebase:

```typescript
// EXISTING PATTERN: Custom Tools (from custom-tools.ts)
// 1. Store in _tables/tools/{name}/tool.js
// 2. Dynamic import at runtime:
const fileUrl = pathToFileURL(filePath).href;
const loadedModule = await import(fileUrl);
const def = loadedModule[`${camelId}ToolDefinition`];

// FOR WORKFLOWS: Same pattern
// 1. Store in _tables/workflows-f/{id}/workflow.ts
// 2. Dynamic import:
const workflowModule = await import(fileUrl);
const workflow = workflowModule.workflow;
const metadata = workflowModule.workflowMetadata;
```

**Primitive Discovered:**
- Storage: `_tables/workflows-f/{id}/workflow.ts`
- Dynamic import via `pathToFileURL(filePath).href`
- Exports: `workflow` (the Mastra workflow), `workflowMetadata` (for UI)

**Implementation Note:** We need to create a service similar to `custom-tools.ts` for loading workflows. Call it `workflow-loader.ts`. The generated workflow.ts exports both the executable workflow and metadata.

**Source:** Existing pattern in `app/api/tools/services/custom-tools.ts`

---

### RQ-9: JSON Schema to Zod

**Why It Matters:** Our schemas are stored as JSON Schema. Transpiler must generate Zod code strings.

**Status:** âœ… Answered

**Question:** How do we convert JSON Schema objects to Zod code strings?

**Answer:**
```typescript
// We have two patterns:

// 1. EXISTING: convertComposioSchemaToZod() - Creates RUNTIME Zod objects
// Used when: Executing tools at runtime
const zodSchema = convertComposioSchemaToZod(parameters);

// 2. NEED TO BUILD: generateZodCodeString() - Generates CODE STRINGS
// Used when: Transpiling workflow to workflow.ts file
function generateZodCodeString(jsonSchema: JSONSchema): string {
  // Input:  { type: "object", properties: { url: { type: "string" } } }
  // Output: 'z.object({ url: z.string() })'
  
  const { type, properties, required = [] } = jsonSchema;
  
  if (type !== "object" || !properties) {
    return "z.any()";
  }
  
  const fields = Object.entries(properties).map(([key, prop]) => {
    let zodType = typeToZodCode(prop.type);
    if (prop.description) zodType += `.describe("${prop.description}")`;
    if (!required.includes(key)) zodType += ".optional()";
    return `${key}: ${zodType}`;
  });
  
  return `z.object({ ${fields.join(", ")} })`;
}

function typeToZodCode(type: string): string {
  switch (type) {
    case "string": return "z.string()";
    case "number": return "z.number()";
    case "boolean": return "z.boolean()";
    case "array": return "z.array(z.any())";
    case "object": return "z.record(z.string(), z.any())";
    default: return "z.any()";
  }
}
```

**Primitive Discovered:**
- Existing: `convertComposioSchemaToZod()` â†’ runtime Zod objects âœ…
- Need to build: `generateZodCodeString()` â†’ code strings for transpilation
- Similar pattern exists in `transpiler.ts` (`fieldTypeToZod` function)

**Implementation Note:** We need to create a new function that generates Zod CODE as strings, similar to how `transpiler.ts` does `fieldTypeToZod()`. The logic is simpler than runtime conversion since we're just generating string output.

**Source:** 
- `app/api/tools/services/composio-tools.ts` (convertComposioSchemaToZod)
- `app/api/tools/services/transpiler.ts` (fieldTypeToZod, generateSchema)

---

### RQ-10: Nested Workflows

**Why It Matters:** Loop/ForEach containers have child steps. May need nested workflows.

**Status:** âœ… Answered

**Question:** How are nested workflows (workflow-as-step) composed in Mastra?

**Answer:**
```typescript
// From Mastra docs: Workflows can be used as steps directly

// 1. Create child workflow
const childWorkflow = createWorkflow({
  id: "child-workflow",
  inputSchema: z.object({ message: z.string() }),
  outputSchema: z.object({ emphasized: z.string() })
})
  .then(step1)
  .then(step2)
  .commit();

// 2. Use child workflow as a step in parent
export const parentWorkflow = createWorkflow({
  id: "parent-workflow",
  inputSchema: z.object({ message: z.string() }),
  outputSchema: z.object({ emphasized: z.string() })
})
  .then(childWorkflow)  // <-- Use workflow directly as step
  .commit();

// For loops with child steps:
const loopBody = createWorkflow({ id: "loop-body", ... })
  .then(step1)
  .then(step2)
  .commit();

parentWorkflow
  .dountil(loopBody, condition)  // <-- Loop over a workflow
  .commit();
```

**Primitive Discovered:**
- Child workflows can be passed directly to `.then()`, `.dountil()`, `.foreach()`, etc.
- Child workflow inputSchema/outputSchema must match parent's expectations
- Use `cloneWorkflow()` if you need separate tracking in logs

**Implementation Note:** For our containers (Loop, ForEach) with `childStepIds`, we'll generate a child workflow from those steps and pass it to the loop primitive. This keeps the generated code clean and matches Mastra's composition model.

**Source:** https://mastra.ai/docs/workflows/overview (Workflows as steps section)

---

### RQ-11: Pre-save Validation

**Why It Matters:** Catch errors before saving invalid code.

**Status:** âœ… Answered (practical decision)

**Question:** What validation can we perform on generated code? Syntax check? Type check?

**Answer:**

**Options:**
| Option | Pros | Cons |
|--------|------|------|
| A: TypeScript compiler API | Full type checking | Heavy, slow |
| B: Esbuild parse | Fast syntax check | No type errors |
| C: Just save & let runtime fail | Simplest | Bad UX |
| D: Schema validation only | Fast, catches data issues | Won't catch code bugs |

**Our Choice:** D + Basic structural validation

```typescript
// Pre-save validation:
1. Validate WorkflowDefinition with Zod schema (we have this)
2. Check all steps have required fields (id, type, inputSchema, outputSchema)
3. Check control flow references valid step IDs
4. Check mappings reference valid steps
5. For Composio steps, verify toolId exists

// Skip for MVP:
- TypeScript compilation (too heavy)
- Full Mastra schema validation (would need to run their code)
```

**Implementation Note:** Since transpilation is deterministic, if the source data (WorkflowDefinition) is valid, the generated code should be valid. Focus validation on the source, not the output.

**Source:** Practical decision based on performance trade-offs 

---

### RQ-12: workflowBindings Schema

**Why It Matters:** Need to extend `AgentConfig` to support workflow assignment.

**Status:** âœ… Answered (designed from existing patterns)

**Question:** How should `workflowBindings` be structured? What metadata is needed?

**Answer:**
```typescript
// EXISTING: ConnectionToolBinding (from _tables/types.ts)
type ConnectionToolBinding = {
  toolId: string;        // e.g., "GMAIL_SEND_EMAIL"
  connectionId: string;  // e.g., "ca_abc123"
  toolkitSlug: string;   // e.g., "gmail"
};

// NEW: WorkflowBinding (following same pattern)
type WorkflowBinding = {
  workflowId: string;              // e.g., "wf-8GNiiS0n7DUb"
  connectionBindings: {            // Maps each toolkit to a connectionId
    [toolkitSlug: string]: string; // e.g., { "gmail": "ca_abc123", "slack": "ca_xyz789" }
  };
};

// UPDATED AgentConfig (in _tables/types.ts)
type AgentConfig = {
  // ... existing fields ...
  toolIds: string[];                          // Custom tools
  connectionToolBindings?: ConnectionToolBinding[];  // Composio tools
  workflowBindings?: WorkflowBinding[];       // NEW: Assigned workflows
};
```

**Primitive Discovered:**
- Pattern: Similar to `ConnectionToolBinding` but with nested connection map
- Reason for map: Workflow may use multiple toolkits (e.g., Gmail + Slack)
- At runtime: `workflowBinding.connectionBindings` becomes `runtimeContext.get("connections")`

**Implementation Note:** When saving workflow assignment, UI shows required toolkits (extracted from workflow metadata), user picks connections for each, we save the binding.

**Source:** Existing pattern in `_tables/types.ts`, `ConnectionToolBinding`

---

### RQ-13: Connection Passing at Runtime

**Why It Matters:** When agent invokes workflow, it needs to pass the bound connection IDs.

**Status:** âœ… Answered (designed from existing patterns + Mastra docs)

**Question:** How does the agent pass connection IDs to the workflow at runtime?

**Answer:**
```typescript
// EXISTING PATTERN: Connection tools at runtime (from chat-service.ts)
// Connection tools get connectionId from the binding itself:
const toolDef = await getConnectionToolExecutable(userId, binding);
// Inside getConnectionToolExecutable:
const result = await client.tools.execute(toolId, input, binding.connectionId);

// FOR WORKFLOWS: Similar but via runtimeContext
// 1. Agent looks up workflowBinding for the workflow
const workflowBinding = agentConfig.workflowBindings?.find(
  b => b.workflowId === workflowId
);

// 2. Create runtimeContext with the connection bindings
const runtimeContext = new RuntimeContext({
  connections: workflowBinding.connectionBindings
  // e.g., { "gmail": "ca_abc123", "slack": "ca_xyz789" }
});

// 3. Run workflow with context
const run = await workflow.createRunAsync({ runtimeContext });
const result = await run.start({ inputData });

// 4. Inside generated step code:
execute: async ({ inputData, runtimeContext }) => {
  const connections = runtimeContext.get("connections");
  const gmailConnectionId = connections?.["gmail"];
  // Use gmailConnectionId when calling Composio
}
```

**Primitive Discovered:**
- Pattern: `runtimeContext` carries connection bindings from agent config to workflow steps
- Flow: AgentConfig.workflowBindings â†’ RuntimeContext â†’ Step execute
- Similarity to: Connection tools (binding carries connectionId directly)

**Implementation Note:** We need to build a `getWorkflowExecutable(userId, workflowBinding)` similar to `getConnectionToolExecutable` that loads the workflow and wraps it with the connection context.

**Source:** 
- Existing pattern in `app/api/tools/services/composio-tools.ts` (getConnectionToolExecutable)
- Mastra docs on RuntimeContext 

---

### RQ-14: Capabilities UI

**Why It Matters:** Users need to assign workflows to agents via the "Assigned Capabilities" UI.

**Status:** âœ… Answered (designed from existing patterns)

**Question:** How should the Workflows section in Capabilities tab work?

**Answer:**

**Current State:**
- `CapabilitiesTab.tsx` shows Workflows section with MOCK_WORKFLOWS
- No "Manage" button yet for workflows
- `WorkflowCard.tsx` is a simple display component

**UI Flow (to implement):**
```
1. User clicks "Manage" in Workflows section
   â””â”€â”€ Opens WorkflowEditorPanel (similar to ConnectionToolEditorPanel)

2. Panel shows available workflows from _tables/workflows-f/
   â”œâ”€â”€ Each workflow card shows:
   â”‚   â”œâ”€â”€ Name, Description
   â”‚   â”œâ”€â”€ Required connections (e.g., "Requires: Gmail, Slack")
   â”‚   â””â”€â”€ Status: âœ… Ready | âš ï¸ Needs Connection Setup

3. User clicks on a workflow to configure
   â””â”€â”€ Shows connection assignment:
       â”œâ”€â”€ Gmail â†’ [Select Connection â–¼]
       â””â”€â”€ Slack â†’ [Select Connection â–¼]

4. User saves
   â””â”€â”€ Creates WorkflowBinding with connectionBindings map
```

**Files to Create/Modify:**
```
NEW: app/(pages)/workforce/components/WorkflowEditorPanel.tsx
NEW: app/(pages)/workforce/components/agent-modal/hooks/useWorkflowAssignment.ts
NEW: app/api/workforce/[agentId]/workflows/route.ts (GET/POST bindings)
NEW: app/api/workforce/[agentId]/workflows/available/route.ts
MOD: app/(pages)/workforce/components/agent-modal/components/tabs/CapabilitiesTab.tsx
MOD: _tables/types.ts (add WorkflowBinding)
```

**API Pattern (following connection tools):**
```typescript
// GET /api/workforce/[agentId]/workflows
{ bindings: WorkflowBinding[] }

// POST /api/workforce/[agentId]/workflows
{ bindings: WorkflowBinding[] }

// GET /api/workforce/[agentId]/workflows/available
{ workflows: WorkflowMetadata[] }
// Where WorkflowMetadata includes:
// { id, name, description, requiredConnections: string[] }
```

**Source:** Existing pattern in `ConnectionToolEditorPanel.tsx`, `useConnectionTools.ts`

---

### RQ-15: File Structure and Imports

**Why It Matters:** Need to know how to name/structure files for dynamic loading.

**Status:** âœ… Answered

**Question:** What file structure should we use? How does dynamic import work for workflows?

**Answer:**
```
_tables/workflows-f/{id}/
â”œâ”€â”€ workflow.json    # Editor state (our WorkflowDefinition)
â””â”€â”€ workflow.ts      # Transpiled Mastra workflow
```

**Generated workflow.ts structure:**
```typescript
// Auto-generated - do not edit manually
import { createWorkflow, createStep } from "@mastra/core/workflows";
import { z } from "zod";
import { getComposioClient } from "@/app/api/connections/services/composio";

// Step definitions
const step1 = createStep({ ... });
const step2 = createStep({ ... });

// Workflow definition
export const workflow = createWorkflow({
  id: "wf-8GNiiS0n7DUb",
  inputSchema: z.object({ ... }),
  outputSchema: z.object({ ... })
})
  .then(step1)
  .then(step2)
  .commit();

// For agent integration - metadata export
export const workflowMetadata = {
  id: "wf-8GNiiS0n7DUb",
  name: "Process Job Applications",
  description: "...",
  requiredConnections: ["gmail", "slack"],
};
```

**Primitive Discovered:**
- File structure: `workflow.json` + `workflow.ts` in same folder
- Export name: `workflow` (the committed workflow instance)
- Metadata export: `workflowMetadata` for agent assignment UI
- Dynamic import pattern: `pathToFileURL(filePath).href` (like custom-tools.ts)

**Implementation Note:** Unlike current tools (tool.js = JavaScript), we'll generate TypeScript (workflow.ts) since Mastra expects TypeScript. May need to compile or use ts-node/tsx at runtime for dynamic import.

**Source:** Existing pattern in `app/api/tools/services/custom-tools.ts`

---

## Part 3: Integration Patterns

### RQ-16: Editor State to Mastra Workflow Mapping

**Why It Matters:** Need complete mapping from our types to Mastra types.

**Status:** â“ Not Researched

**Questions:**
1. Does our `WorkflowStep` have all fields needed for `createStep`?
2. Does our `WorkflowDefinition` have all fields needed for `createWorkflow`?
3. What's missing?

**Mapping Table:**

| Our Type | Mastra Type | Status |
|----------|-------------|--------|
| `WorkflowDefinition.inputSchema` | `createWorkflow({ inputSchema })` | â“ |
| `WorkflowDefinition.outputSchema` | `createWorkflow({ outputSchema })` | â“ |
| `WorkflowStep.inputSchema` | `createStep({ inputSchema })` | â“ |
| `WorkflowStep.outputSchema` | `createStep({ outputSchema })` | â“ |
| `WorkflowStep.type === "composio"` | execute body | â“ |
| `controlFlow.type === "branch"` | `.branch()` | â“ |
| `controlFlow.type === "parallel"` | `.parallel()` | â“ |
| `mappings` | `.map()` | â“ |

**Source:** 

---

## Summary

### Primitives We'll Use

| What | Primitive | From | Confirmed? |
|------|-----------|------|------------|
| Create step | `createStep({ id, inputSchema, outputSchema, execute })` | @mastra/core/workflows | âœ… |
| Create workflow | `createWorkflow({ id, inputSchema, outputSchema })` | @mastra/core/workflows | âœ… |
| Sequential | `.then(step)` | Workflow builder | âœ… |
| Branching | `.branch([ [condition, step], ... ])` | Workflow builder | âœ… |
| Parallel | `.parallel([step1, step2])` | Workflow builder | âœ… |
| Loop until | `.dountil(step, condition)` | Workflow builder | âœ… |
| Loop while | `.dowhile(step, condition)` | Workflow builder | âœ… |
| For each | `.foreach(step, { concurrency? })` | Workflow builder | âœ… |
| Data mapping | `.map(async ({ inputData, getStepResult, getInitData }) => ...)` | Workflow builder | âœ… |
| Commit | `.commit()` | Workflow builder | âœ… |
| Runtime context | `runtimeContext.get("key")` | Step execute | âœ… |
| Composio execute | `client.tools.execute()` | Composio SDK | âœ… (existing code) |

### Blockers & Dead Ends

| Issue | Impact | Resolution |
|-------|--------|------------|
| - | - | - |

### Key Learnings

1. **Mastra workflow composition is declarative** â€” Use `.then()`, `.branch()`, `.parallel()`, `.foreach()` to compose steps. All control flow is explicit.

2. **RuntimeContext is the bridge** â€” Connection IDs flow from AgentConfig â†’ runtimeContext â†’ step execute. This is how Composio tools get their auth.

3. **Follow existing patterns** â€” Our codebase already has `ConnectionToolBinding` and `ConnectionToolEditorPanel`. Workflows follow the same pattern with an extra layer (mapping multiple toolkits to connections).

4. **Transpilation is deterministic** â€” Given valid WorkflowDefinition, generated code will be valid. Focus validation on source, not output.

5. **Nested workflows for containers** â€” Loop/ForEach child steps become child workflows, passed directly to `.dountil()` or `.foreach()`.

6. **Two artifacts on save** â€” `workflow.json` (editor state) + `workflow.ts` (executable Mastra code). Both stored in `_tables/workflows-f/{id}/`.

---

## Exit Criteria

- [x] All RQ questions answered (15/15)
- [x] Summary table complete
- [x] No unresolved blockers
- [x] Key learnings documented
- [ ] Mapping table (RQ-16) fully populated (deferred to Phase 6)

**Next Step:** Phase 6 Implementation Plan (Transpilation Engine)

---

## Resources Used

- https://mastra.ai/docs/workflows/overview
- https://mastra.ai/docs/workflows/control-flow
- Existing code: `app/api/tools/services/transpiler.ts`
- Existing code: `app/api/tools/services/composio-tools.ts`
- Existing code: `app/api/workforce/services/agent-config.ts`
- Existing code: `_tables/types.ts`
- Existing code: `_tables/tools/hohoho/tool.js`

