# Phase 11.2: Lessons Learned & Correct Approach

**Status:** ğŸ“š Retrospective  
**Date:** December 8, 2025  
**Purpose:** Document everything we learned and how we should have done this from the start

---

## Executive Summary

We spent significant effort trying to work around Next.js/Turbopack dynamic import restrictions by building complex workarounds (database storage, code execution, ES module transformation). **The correct solution was always simpler: construct Mastra workflows from JSON at runtime, because Mastra workflows are JavaScript objects, not files.**

**Key Insight:** Mastra workflows are created with `createWorkflow()` and `createStep()` - they're in-memory objects. We never needed to load files at all.

---

## The Journey: What We Tried

### Phase 1: The Original Problem

**Problem:** Next.js 16 with Turbopack blocks dynamic imports with computed paths:
```typescript
// âŒ This fails in Turbopack
const workflowPath = `./_tables/workflows/${workflowId}/workflow.ts`;
const module = await import(workflowPath); // Error: "expression is too dynamic"
```

**Initial Assumption:** We need to load transpiled `.ts` files at runtime.

**Workaround Applied:** Disabled Turbopack, used Webpack instead (`--webpack` flag).

### Phase 2: Database Storage Approach (Wrong Path)

**What We Built:**
- `storage/database.ts` - Store transpiled code in database
- `workflow-executor.ts` - Execute code from database with ESâ†’CommonJS transformation
- Complex sandboxing and module whitelisting

**Why It Seemed Right:**
- Solves Turbopack issue (no dynamic file imports)
- Works in serverless (read-only filesystem)
- Code stored in database, loaded at runtime

**Why It Was Wrong:**
- **Overcomplicated** - We're executing user-generated code in a sandbox
- **Unnecessary** - Mastra workflows don't need to be files
- **Maintenance burden** - ES module transformation, security concerns, error handling
- **Still generates code** - We're still transpiling to TypeScript, just storing it differently

**Files Created (Now Unused):**
- `app/api/workflows/services/storage/database.ts`
- `app/api/workflows/services/workflow-executor.ts` (if it existed)
- Test scripts for database approach

### Phase 3: Runtime Construction (Correct Path)

**What We Built:**
- `workflow-builder.ts` - Construct workflows from JSON at runtime
- `workflow-loader.ts` - Load JSON, build workflow, cache it
- Direct use of Mastra's `createWorkflow()` and `createStep()`

**Why It's Right:**
- âœ… **Matches Mastra's design** - Workflows are objects, not files
- âœ… **No dynamic imports** - We read JSON (static file), construct in memory
- âœ… **Simple** - Direct API usage, no code generation needed
- âœ… **Type-safe** - Use Zod schemas directly, no string manipulation
- âœ… **Maintainable** - Standard patterns, easy to debug

**Files Created (Keep These):**
- `app/api/workflows/services/workflow-builder.ts`
- `app/api/workflows/services/workflow-loader.ts` (modified)
- `app/api/tools/services/workflow-tools.ts` (modified)

---

## Critical Learnings

### Learning 1: Mastra Workflows Are Objects, Not Files

**What We Thought:**
- Workflows need to be transpiled TypeScript files
- We need to load and execute these files at runtime
- Dynamic imports are required

**Reality:**
```typescript
// Mastra workflows are just JavaScript objects
const workflow = createWorkflow({
  id: "my-workflow",
  inputSchema: z.object({ ... }),
  outputSchema: z.any()
})
  .then(step1)
  .then(step2)
  .commit();

// This object can be created at runtime from JSON
// No files needed!
```

**Key Insight:** The transpiler generates code that creates these objects. We can just create the objects directly from JSON instead of generating code that creates them.

### Learning 2: JSON Schema â†’ Zod Conversion at Runtime

**What We Thought:**
- Need to generate TypeScript code with Zod schemas
- Schema conversion must happen at transpile time

**Reality:**
```typescript
// We can convert JSON Schema to Zod objects at runtime
function jsonSchemaToZod(schema: JSONSchema): z.ZodTypeAny {
  if (schema.type === "string") return z.string();
  if (schema.type === "object") {
    const props: Record<string, z.ZodTypeAny> = {};
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      props[key] = jsonSchemaToZod(propSchema);
    }
    return z.object(props);
  }
  // ... etc
}

// Use directly in createWorkflow()
const inputSchema = jsonSchemaToZod(definition.inputSchema);
const workflow = createWorkflow({ inputSchema, ... });
```

**Key Insight:** Zod schemas are runtime objects. We don't need to generate code - we can build the Zod objects directly from JSON Schema.

### Learning 3: Step Execute Functions Can Be Reconstructed

**What We Thought:**
- Transpiler generates execute functions as code strings
- Need to execute generated code to get functions

**Reality:**
```typescript
// We can build execute functions directly from step config
function buildComposioExecuteFunction(step: WorkflowStep) {
  return async ({ inputData, runtimeContext }) => {
    const client = getComposioClient();
    const connections = runtimeContext.get("connections");
    const connectionId = connections?.[step.toolkitSlug];
    const userId = runtimeContext.get("userId");
    
    const result = await client.tools.execute(step.toolId, {
      userId,
      arguments: inputData,
      connectedAccountId: connectionId,
    });
    
    return result.data;
  };
}

// Use directly in createStep()
const execute = buildComposioExecuteFunction(step);
const stepObj = createStep({ id, inputSchema, outputSchema, execute });
```

**Key Insight:** Execute functions are just async functions. We can construct them from step metadata without code generation.

### Learning 4: RuntimeContext Must Be a Class Instance

**What We Tried:**
```typescript
// âŒ Plain object - doesn't work
const runtimeContext = {
  get: (key: string) => binding.connectionBindings,
  connections: binding.connectionBindings
};
```

**Reality:**
```typescript
// âœ… Must use RuntimeContext class
import { RuntimeContext } from "@mastra/core/runtime-context";

const runtimeContext = new RuntimeContext([
  ["connections", binding.connectionBindings],
  ["userId", userId],
]);
```

**Key Insight:** Mastra's type system expects `RuntimeContext` class instances, not plain objects. This caused execution hangs.

### Learning 5: Thenable Workflows Need Wrapping

**What We Discovered:**
- Mastra's committed workflows have a `then()` method (they're "thenable")
- JavaScript's promise resolution tries to await thenable objects
- This causes hangs when workflows are returned from async functions

**Solution:**
```typescript
// Wrap thenable workflows to prevent promise resolution issues
if (typeof workflow.then === 'function') {
  const safeWrapper = Object.create(null);
  safeWrapper.inputSchema = workflow.inputSchema;
  safeWrapper.createRunAsync = workflow.createRunAsync.bind(workflow);
  return safeWrapper;
}
```

**Key Insight:** Committed workflows are thenable, which interferes with promise resolution. We need to extract only the properties we need.

### Learning 6: Workflow Tools Follow Same Pattern as Connection Tools

**What We Learned:**
- Workflows must be wrapped in Vercel AI SDK's `tool()` function
- Same pattern as connection tools: load â†’ wrap â†’ return `ToolDefinition`
- Agent doesn't distinguish between workflow tools and connection tools

**Pattern:**
```typescript
const vercelTool = tool({
  description: metadata.description,
  inputSchema: workflow.inputSchema, // Already Zod, no conversion
  execute: async (input) => {
    const runtimeContext = new RuntimeContext([...]);
    const run = await workflow.createRunAsync({ resourceId: userId });
    const result = await run.start({ inputData: input, runtimeContext });
    return result.result;
  },
});

return {
  id: `workflow-${workflowId}`,
  name: metadata.name,
  description: metadata.description,
  runtime: "workflow",
  run: vercelTool,
};
```

**Key Insight:** Workflow tools are just tools. No special handling needed - follow the same pattern as connection tools.

---

## The Correct Architecture (How We Should Have Done It)

### Core Principle

**Mastra workflows are JavaScript objects created at runtime. We should construct them from JSON definitions, not load transpiled files.**

### Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     User Saves Workflow                      â”‚
â”‚  (workflow.json written to _tables/workflows/{id}/)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Optional: Transpiler Generates .ts             â”‚
â”‚  (For IDE support, debugging, version control)             â”‚
â”‚  NOT used at runtime - just for developer experience       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Agent Requests Workflow Tool                   â”‚
â”‚  (chat-service.ts calls getWorkflowToolExecutable())       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         workflow-loader.ts: Read workflow.json              â”‚
â”‚  - Check cache (by lastModified timestamp)                 â”‚
â”‚  - If cached, return cached workflow object                 â”‚
â”‚  - If not cached, call buildWorkflowFromDefinition()       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      workflow-builder.ts: Construct Workflow Object         â”‚
â”‚  1. Convert runtimeInputs â†’ inputSchema (JSON Schema â†’ Zod) â”‚
â”‚  2. Create workflow base: createWorkflow({ ... })           â”‚
â”‚  3. For each step:                                          â”‚
â”‚     - Convert step schemas (JSON Schema â†’ Zod)               â”‚
â”‚     - Build execute function from step config               â”‚
â”‚     - Create step: createStep({ ... })                      â”‚
â”‚     - Add mapping transform if bindings exist              â”‚
â”‚     - Chain: workflow.then(step)                            â”‚
â”‚  4. Commit: workflow.commit()                              â”‚
â”‚  5. Return workflow object                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         workflow-loader.ts: Cache & Return                   â”‚
â”‚  - Cache workflow object with lastModified timestamp        â”‚
â”‚  - Handle thenable wrapping if needed                       â”‚
â”‚  - Return workflow object                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      workflow-tools.ts: Wrap as Vercel AI SDK Tool           â”‚
â”‚  1. Get workflow object (from loader)                       â”‚
â”‚  2. Get workflow metadata (name, description)                â”‚
â”‚  3. Wrap in tool():                                         â”‚
â”‚     - inputSchema: workflow.inputSchema (already Zod)       â”‚
â”‚     - execute: Create RuntimeContext, run workflow          â”‚
â”‚  4. Return ToolDefinition with .run property               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Agent Executes Workflow Tool                   â”‚
â”‚  - Agent calls tool.execute(input)                          â”‚
â”‚  - RuntimeContext created with connections & userId         â”‚
â”‚  - Workflow run created: createRunAsync({ resourceId })    â”‚
â”‚  - Workflow started: run.start({ inputData, runtimeContext })â”‚
â”‚  - Steps execute with RuntimeContext access                 â”‚
â”‚  - Result returned to agent                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### File Structure (Correct Approach)

```
app/api/workflows/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ workflow-builder.ts          âœ… Core: Construct workflows from JSON
â”‚   â”œâ”€â”€ workflow-loader.ts            âœ… Core: Load & cache workflows
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ crud.ts                   âœ… Read/write workflow.json
â”‚       â”œâ”€â”€ utils.ts                  âœ… File path utilities
â”‚       â””â”€â”€ code-writer.ts            âœ… Optional: Write .ts files for IDE
â”‚
â”œâ”€â”€ [workflowId]/
â”‚   â””â”€â”€ update/
â”‚       â””â”€â”€ services/
â”‚           â”œâ”€â”€ transpiler/           âœ… Optional: Generate .ts files for IDE
â”‚           â””â”€â”€ storage/
â”‚               â””â”€â”€ code-writer.ts    âœ… Optional: Write .ts files
â”‚
app/api/tools/services/
â””â”€â”€ workflow-tools.ts                 âœ… Wrap workflows as agent tools
```

### What We DON'T Need

âŒ **Database storage** - Workflows are objects, not code  
âŒ **Code executor** - No code to execute  
âŒ **ES module transformation** - No modules to transform  
âŒ **Sandboxing** - No user code to sandbox  
âŒ **Module whitelisting** - No dynamic imports  

---

## Implementation Checklist (Clean Rebuild)

### Step 1: Core Workflow Construction

**File:** `app/api/workflows/services/workflow-builder.ts`

**Functions Needed:**
1. `jsonSchemaToZod(schema: JSONSchema): z.ZodTypeAny`
   - Convert JSON Schema to Zod objects at runtime
   - Handle: string, number, boolean, array, object, enum
   - Support required/optional fields

2. `buildComposioExecuteFunction(step: WorkflowStep)`
   - Return async function that:
     - Gets Composio client
     - Extracts connections from RuntimeContext
     - Extracts userId from RuntimeContext
     - Calls `client.tools.execute()` with correct params
     - Returns result.data

3. `getNestedValue(obj: unknown, path: string): unknown`
   - Parse dot-notation paths (e.g., "data.navigatedUrl")
   - Safely access nested properties

4. `buildMappingTransform(stepId: string, bindings: Record<string, StepBindings>)`
   - Return async function that maps:
     - `workflow-input` â†’ `inputData[workflowInputName]`
     - `step-output` â†’ `getNestedValue(getStepResult(sourceStepId), sourcePath)`
     - `literal` â†’ literal value

5. `buildWorkflowFromDefinition(definition: WorkflowDefinition, bindings: Record<string, StepBindings>)`
   - Convert runtimeInputs â†’ inputSchema (JSON Schema â†’ Zod)
   - Create workflow base: `createWorkflow({ id, inputSchema, outputSchema })`
   - Sort steps by listIndex
   - For each step:
     - Convert step schemas (JSON Schema â†’ Zod)
     - Build execute function (Composio/custom/default)
     - Create step: `createStep({ id, inputSchema, outputSchema, execute })`
     - Add mapping if bindings exist: `workflow.map(mappingTransform)`
     - Chain step: `workflow.then(step)`
   - Commit: `workflow.commit()`
   - Return workflow object

**Dependencies:**
- `@mastra/core/workflows` - `createWorkflow`, `createStep`
- `zod` - Schema validation
- `@/app/api/connections/services/composio` - `getComposioClient`
- `@/app/api/workflows/types/*` - Type definitions

### Step 2: Workflow Loading & Caching

**File:** `app/api/workflows/services/workflow-loader.ts`

**Functions Needed:**
1. `getWorkflowExecutable(workflowId: string): Promise<unknown | null>`
   - Read workflow.json using `readWorkflow()`
   - Check cache (by lastModified timestamp)
   - If cached and timestamp matches, return cached workflow
   - If not cached, call `buildWorkflowFromDefinition()`
   - Handle thenable wrapping if needed
   - Cache workflow object with lastModified timestamp
   - Return workflow object

2. `getWorkflowMetadata(workflowId: string): Promise<WorkflowMetadata | null>`
   - Read workflow.json
   - Extract: name, description, requiredConnections, stepCount, lastModified
   - Return metadata object

3. `listAvailableWorkflows(): Promise<WorkflowMetadata[]>`
   - Scan `_tables/workflows/` directory
   - Load metadata for each workflow
   - Sort by lastModified descending
   - Return array

4. `invalidateWorkflowCache(workflowId?: string): void`
   - Clear cache for specific workflow or all workflows

**Caching Strategy:**
- In-memory Map: `Map<workflowId, { workflow: unknown, lastModified: string }>`
- Cache key: workflowId
- Cache invalidation: Compare `lastModified` timestamp from workflow.json
- If timestamp changed, rebuild workflow

**Thenable Handling:**
```typescript
const workflowAny = workflow as any;
if (typeof workflowAny.then === 'function') {
  // Wrap to prevent promise resolution issues
  const safeWrapper = Object.create(null);
  safeWrapper.inputSchema = workflowAny.inputSchema;
  safeWrapper.createRunAsync = workflowAny.createRunAsync.bind(workflowAny);
  return safeWrapper;
}
```

**Dependencies:**
- `@/app/api/workflows/services/workflow-builder` - `buildWorkflowFromDefinition`
- `@/app/api/workflows/services/storage/crud` - `readWorkflow`
- `fs/promises` - Directory scanning

### Step 3: Workflow Tool Wrapping

**File:** `app/api/tools/services/workflow-tools.ts`

**Functions Needed:**
1. `getWorkflowToolExecutable(userId: string, binding: WorkflowBinding): Promise<ToolDefinition | undefined>`
   - Load workflow executable: `getWorkflowExecutable(binding.workflowId)`
   - Handle safe wrapper if thenable
   - Extract `inputSchema` and `createRunAsync` from workflow
   - Load workflow metadata: `getWorkflowMetadata(binding.workflowId)`
   - Create Vercel AI SDK tool:
     ```typescript
     const vercelTool = tool({
       description: metadata.description || `Workflow: ${metadata.name}`,
       inputSchema: workflow.inputSchema, // Already Zod
       execute: async (input: Record<string, unknown>) => {
         // Extract workflow inputs (handle Vercel AI SDK wrapper)
         const workflowInput = input.context || input;
         
         // Create RuntimeContext
         const runtimeContext = new RuntimeContext([
           ["connections", binding.connectionBindings || {}],
           ["userId", userId],
         ]);
         
         // Create workflow run
         const run = await createRunAsync({ resourceId: userId });
         
         // Execute workflow
         const result = await run.start({
           inputData: workflowInput,
           runtimeContext,
         });
         
         // Handle result
         if (result.status === "success") {
           return result.result;
         } else if (result.status === "failed") {
           throw new Error(`Workflow failed: ${JSON.stringify(result.steps)}`);
         }
         
         return { status: result.status, result: result.result };
       },
     });
     ```
   - Return `ToolDefinition` with `.run` property

**Dependencies:**
- `ai` - `tool` function
- `@mastra/core/runtime-context` - `RuntimeContext`
- `@/app/api/workflows/services/workflow-loader` - `getWorkflowExecutable`, `getWorkflowMetadata`
- `@/_tables/types` - `ToolDefinition`, `WorkflowBinding`

### Step 4: Integration with Chat Service

**File:** `app/api/workforce/[agentId]/chat/services/chat-service.ts`

**Modifications:**
- In `buildToolMap()`, add workflow tools:
  ```typescript
  const workflowBindings = agentConfig.workflowBindings || [];
  for (const binding of workflowBindings) {
    const toolDef = await getWorkflowToolExecutable(userId, binding);
    if (toolDef) {
      toolMap[toolDef.id] = toolDef.run;
    }
  }
  ```

**Dependencies:**
- `@/app/api/tools/services/workflow-tools` - `getWorkflowToolExecutable`

---

## Key Principles for Clean Implementation

### 1. Workflows Are Objects, Not Files
- Never generate code to create workflows
- Always construct workflows from JSON at runtime
- Use Mastra's APIs directly: `createWorkflow()`, `createStep()`

### 2. JSON Schema â†’ Zod at Runtime
- Don't generate Zod code strings
- Convert JSON Schema to Zod objects directly
- Use Zod schemas in `createWorkflow()` and `createStep()`

### 3. Execute Functions Are Just Functions
- Don't generate execute function code
- Build execute functions from step metadata
- Use closures to capture step configuration

### 4. RuntimeContext Must Be Class Instance
- Always use `new RuntimeContext([...])`
- Never use plain objects
- Pass connections and userId as array of tuples

### 5. Cache Workflow Objects
- Cache constructed workflow objects
- Invalidate by `lastModified` timestamp
- Avoid rebuilding on every request

### 6. Handle Thenable Workflows
- Check for `then()` method
- Extract only needed properties
- Wrap in plain object to prevent promise resolution

### 7. Follow Connection Tools Pattern
- Workflow tools follow same pattern as connection tools
- Wrap in Vercel AI SDK `tool()`
- Return `ToolDefinition` with `.run` property
- Agent doesn't distinguish between tool types

---

## What to Delete (Clean Slate)

### Files to Delete
1. `app/api/workflows/services/storage/database.ts` - Unused database approach
2. `app/api/workflows/services/storage/generated-code.ts` - Duplicate of code-writer
3. `lib/composio.ts` - Unused wrapper
4. `scripts/debug-transformation.ts` - Dev-only test script
5. `scripts/test-real-workflow.ts` - Dev-only test script
6. `scripts/test-summary.ts` - Dev-only test script
7. `scripts/test-workflow-execution.ts` - Dev-only test script
8. `app/api/workflows/services/README.md` - Outdated (describes database approach)
9. `app/api/workflows/services/QUICK_TEST.md` - Outdated
10. `app/api/workflows/services/TESTING.md` - Outdated

### Files to Update
1. `app/api/workflows/services/storage/index.ts` - Remove `generated-code` export
2. `TURBOPACK-DISABLED.md` - Update: Phase 12 solved the issue

### Files to Keep (Core Implementation)
1. `app/api/workflows/services/workflow-builder.ts` - âœ… Core
2. `app/api/workflows/services/workflow-loader.ts` - âœ… Core
3. `app/api/tools/services/workflow-tools.ts` - âœ… Core
4. `app/api/workflows/services/storage/crud.ts` - âœ… Core
5. `app/api/workflows/services/storage/utils.ts` - âœ… Core
6. `app/api/workflows/services/storage/code-writer.ts` - âœ… Optional (IDE support)
7. `app/api/workflows/[workflowId]/update/services/transpiler/` - âœ… Optional (IDE support)

---

## Acceptance Criteria (Clean Implementation)

| # | Criterion | How to Verify |
|---|-----------|---------------|
| AC-11.2.1 | Workflow constructed from JSON | Call `buildWorkflowFromDefinition()` â†’ returns workflow object with `createRunAsync()` |
| AC-11.2.2 | JSON Schema â†’ Zod conversion works | Workflow `inputSchema` is valid Zod schema |
| AC-11.2.3 | Composio steps execute correctly | Run workflow â†’ Composio tools execute with connections from RuntimeContext |
| AC-11.2.4 | Data mappings work | Run workflow â†’ step inputs mapped from previous steps using bindings |
| AC-11.2.5 | RuntimeContext passed correctly | Execute workflow â†’ steps receive connections and userId via RuntimeContext |
| AC-11.2.6 | Agent can invoke workflow | Chat with agent â†’ workflow tool appears and executes successfully |
| AC-11.2.7 | Workflow caching works | Load same workflow twice â†’ second load uses cache |
| AC-11.2.8 | No dynamic import errors | Load workflow â†’ no "expression is too dynamic" error |
| AC-11.2.9 | Thenable workflows handled | Workflow with `then()` method â†’ wrapped correctly, no promise resolution issues |
| AC-11.2.10 | Workflow execution succeeds | Agent invokes workflow â†’ completes successfully with correct results |

---

## Summary: The Right Way

### What We Should Have Done From the Start

1. **Read Mastra docs first** - Understand that workflows are objects, not files
2. **Skip code generation** - Construct workflows directly from JSON
3. **Use Mastra APIs directly** - `createWorkflow()`, `createStep()`, `RuntimeContext`
4. **Keep it simple** - No database, no code execution, no transformation
5. **Follow existing patterns** - Workflow tools follow connection tools pattern

### The Correct Approach (3 Core Files)

1. **`workflow-builder.ts`** - Construct workflows from JSON
2. **`workflow-loader.ts`** - Load & cache workflows
3. **`workflow-tools.ts`** - Wrap workflows as agent tools

That's it. Everything else is optional (transpiler for IDE support) or unnecessary (database, executor, transformation).

### Key Insight

**Mastra workflows are JavaScript objects. We should construct them from JSON at runtime, not load transpiled files. The transpiler is useful for IDE support, but not required for execution.**

---

## Next Steps

1. âœ… **Document lessons learned** (this document)
2. â³ **Delete unused files** (database.ts, test scripts, outdated docs)
3. â³ **Clean rebuild** (implement the 3 core files from scratch)
4. â³ **Test** (verify all acceptance criteria)
5. â³ **Update documentation** (new README describing runtime construction)

---

**Last Updated:** December 8, 2025  
**Status:** Ready for clean rebuild



