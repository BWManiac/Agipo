# Task 15.1: Workflow Editor Research

**Status:** âœ… Complete  
**Date:** December 6, 2025  
**Parent Task:** [15-workflow-editor.md](./15-workflow-editor.md)
**Research Duration:** ~1 hour

---

## How to Use This Document

This is a **research log**. Each section contains:
1. **The Question** - What we need to find out
2. **Why It Matters** - Which product requirement it unlocks (mapped to PR-x.x)
3. **Answer** - What we discovered (filled in during research)
4. **Primitive** - The exact code/function we'll use
5. **Implementation Note** - How this affects our code

**Status Key:** â“ Not Researched | ðŸ” In Progress | âœ… Answered | âš ï¸ Blocked

---

## Quick Reference: Questions â†’ Requirements

| Question | Requirement | Status |
|----------|-------------|--------|
| [RQ-1: Workflow Input Schema](#rq-1-how-do-we-define-workflow-input-schema) | PR-8 Runtime Inputs | âœ… |
| [RQ-2: Step Definition](#rq-2-how-do-we-define-a-step) | PR-2 IPO Model | âœ… |
| [RQ-3: Data Between Steps](#rq-3-how-does-data-pass-between-steps) | PR-9 Data Mapping | âœ… |
| [RQ-4: Sequential Execution](#rq-4-how-do-we-chain-steps-sequentially) | PR-2 IPO Model | âœ… |
| [RQ-5: Parallel Execution](#rq-5-how-do-we-run-steps-in-parallel) | PR-6 Control Flow | âœ… |
| [RQ-6: Conditional Branching](#rq-6-how-do-we-branch-conditionally) | PR-6 Control Flow | âœ… |
| [RQ-7: Error Handling](#rq-7-how-are-errors-handled) | PR-11 Error Handling | âœ… |
| [RQ-8: Workflow Execution](#rq-8-how-do-we-execute-a-workflow) | PR-10 Testing | âœ… |
| [RQ-8.5: Non-Sequential Access](#rq-85-how-do-we-access-non-sequential-step-outputs) | PR-9 Data Mapping | âœ… |
| [RQ-8.6: Workflow Termination](#rq-86-can-we-terminate-a-running-workflow) | PR-10 Testing | ðŸ” |
| [RQ-9: Code-Gen vs Runtime](#rq-9-does-mastra-require-code-files-or-accept-runtime-definitions) | Architecture | âœ… |
| [RQ-10: Composio Output Schemas](#rq-10-does-composio-expose-output-schemas) | PR-1 Node Discovery | âœ… |
| [RQ-11: Composio Toolkit Extraction](#rq-11-how-do-we-get-toolkit-from-tool) | PR-4 Connection Req | âœ… |
| [RQ-12: Composio + Mastra Integration](#rq-12-how-do-we-wrap-composio-tools-as-mastra-steps) | PR-2, PR-4 | âœ… |

---

## Part 1: Mastra Workflow Research

### RQ-1: How do we define workflow input schema?

**Why It Matters:** PR-8 (Runtime Inputs) - Workflows need to accept inputs from agents at execution time.

**Status:** âœ… Answered

**Question:** When creating a workflow, how do we declare what inputs it accepts? What's the schema format?

**Answer:**
```typescript
import { createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

const myWorkflow = createWorkflow({
  id: 'my-workflow',
  inputSchema: z.object({
    jobUrl: z.string(),
    userId: z.string(),
  }),
  outputSchema: z.object({
    resumeId: z.string(),
    status: z.string(),
  }),
})
  .then(step1)
  .then(step2)
  .commit();
```

**Primitive Discovered:**
- Function: `createWorkflow()`
- Signature: `createWorkflow({ id, inputSchema, outputSchema })`
- Schema format: **Zod schemas** - standard Zod objects

**Implementation Note:**
- The workflow `inputSchema` MUST match the first step's `inputSchema`
- The workflow `outputSchema` MUST match the final step's `outputSchema`
- Input data is passed when calling `createRunAsync().start({ inputData: {...} })`

**Source:** [Mastra Workflows Overview](https://mastra.ai/docs/workflows/overview)

---

### RQ-2: How do we define a step?

**Why It Matters:** PR-2 (IPO Model) - Each node in our editor becomes a step with input/output.

**Status:** âœ… Answered

**Question:** What is the `createStep()` signature? How do we define what a step accepts and returns?

**Answer:**
```typescript
import { createStep } from '@mastra/core/workflows';
import { z } from 'zod';

const fetchJobStep = createStep({
  id: 'fetch-job',
  inputSchema: z.object({
    jobUrl: z.string(),
  }),
  outputSchema: z.object({
    title: z.string(),
    company: z.string(),
    requirements: z.array(z.string()),
  }),
  execute: async ({ inputData }) => {
    // Business logic here - can call APIs, agents, tools
    const jobData = await scrapeJob(inputData.jobUrl);
    return {
      title: jobData.title,
      company: jobData.company,
      requirements: jobData.requirements,
    };
  },
});
```

**Primitive Discovered:**
- Function: `createStep()`
- Signature: `createStep({ id, inputSchema, outputSchema, execute })`
- Input schema: Zod schema defining what the step accepts
- Output schema: Zod schema defining what the step returns
- Execute: `async ({ inputData, getStepResult, getInitData, mapiVariable }) => {...}`

**Implementation Note:**
- The `execute` function is where all business logic lives
- Can call external APIs, agents, tools, functions in the codebase
- Steps are the building blocks - composable and reusable
- Steps can also be workflows (nested workflows)

**Source:** [Mastra Workflows Overview](https://mastra.ai/docs/workflows/overview)

---

### RQ-3: How does data pass between steps?

**Why It Matters:** PR-9 (Data Mapping) - When Node A outputs `{title, company}` and Node B needs `{jobTitle}`, how does the mapping work?

**Status:** âœ… Answered

**Question:** Does Mastra use a shared context object? Return values? How do we access previous step's output?

**Answer:**
```typescript
// Default: Previous step's outputSchema becomes next step's inputSchema
workflow.then(stepA).then(stepB) // stepB receives stepA's output directly

// With mapping: Use .map() to transform data between steps
workflow
  .then(stepA)
  .map(({ inputData, getStepResult, getInitData, mapVariable }) => {
    // Option 1: Direct transformation
    return {
      jobTitle: inputData.title,  // Rename field
      companyName: inputData.company,
    };
    
    // Option 2: Access specific step result
    const stepAResult = getStepResult('step-a');
    
    // Option 3: Access initial workflow input
    const initialInput = getInitData();
    
    // Option 4: Declarative mapping
    return mapVariable({
      jobTitle: { from: 'title' },
      companyName: { from: 'company' },
    });
  })
  .then(stepB);
```

**Primitive Discovered:**
- Mechanism: Each step's `outputSchema` flows to next step's `inputSchema`
- How to access previous output: Via `inputData` in execute or via `.map()` helper
- How to map fields: `.map()` method with helper functions:
  - `getStepResult(stepId)` - Access any step's output
  - `getInitData()` - Access workflow's initial input
  - `mapVariable({ field: { from: 'sourceField' } })` - Declarative field mapping

**Implementation Note:**
- Core principle: Each step's outputSchema must match next step's inputSchema
- If schemas don't match, use `.map()` to transform
- For our editor: We need to code-gen the `.map()` calls based on user's visual connections

**Source:** [Mastra Control Flow - Input data mapping](https://mastra.ai/docs/workflows/control-flow) 

---

### RQ-4: How do we chain steps sequentially?

**Why It Matters:** PR-2 (IPO Model) - Most workflows are linear: Step A â†’ Step B â†’ Step C.

**Status:** âœ… Answered

**Question:** What is the `.then()` or equivalent method signature?

**Answer:**
```typescript
const workflow = createWorkflow({ id: 'my-workflow', inputSchema, outputSchema })
  .then(fetchJobStep)
  .then(analyzeRequirementsStep)
  .then(generateResumeStep)
  .commit();
```

**Primitive Discovered:**
- Method: `.then(step)`
- Signature: `workflow.then(step: Step) => WorkflowBuilder`
- Chainable - returns workflow builder for further chaining

**Implementation Note:**
- Steps execute in order
- Each step receives the previous step's output as its input
- Must call `.commit()` at the end to finalize the workflow
- Sequential is the default/simplest control flow

**Source:** [Mastra Control Flow](https://mastra.ai/docs/workflows/control-flow)

---

### RQ-5: How do we run steps in parallel?

**Why It Matters:** PR-6 (Control Flow) - Some workflows need parallel execution.

**Status:** âœ… Answered

**Question:** What is the `.parallel()` method signature? How do outputs merge?

**Answer:**
```typescript
const workflow = createWorkflow({ id: 'my-workflow', inputSchema, outputSchema })
  .parallel([
    fetchLinkedInStep,    // id: 'fetch-linkedin'
    fetchGithubStep,      // id: 'fetch-github'
    fetchPortfolioStep,   // id: 'fetch-portfolio'
  ])
  .then(mergeProfilesStep) // Receives: { 'fetch-linkedin': {...}, 'fetch-github': {...}, ... }
  .commit();

// The next step's inputSchema must handle the parallel output structure:
const mergeProfilesStep = createStep({
  inputSchema: z.object({
    'fetch-linkedin': z.object({ ... }),
    'fetch-github': z.object({ ... }),
    'fetch-portfolio': z.object({ ... }),
  }),
  // ...
});
```

**Primitive Discovered:**
- Method: `.parallel([step1, step2, step3])`
- Signature: `workflow.parallel(steps: Step[]) => WorkflowBuilder`
- Output merging: Object keyed by step ID â†’ `{ [stepId]: stepOutput }`

**Implementation Note:**
- All parallel steps execute simultaneously
- Each step's output is keyed by its `id`
- Next step's `inputSchema` must match this `{ [stepId]: OutputSchema }` structure
- For our editor: Need to visualize parallel branches and auto-generate the merged input schema

**Source:** [Mastra Control Flow](https://mastra.ai/docs/workflows/control-flow)

---

### RQ-6: How do we branch conditionally?

**Why It Matters:** PR-6 (Control Flow) - If/else logic based on step output.

**Status:** âœ… Answered

**Question:** What is the `.branch()` or conditional method signature?

**Answer:**
```typescript
const workflow = createWorkflow({ id: 'my-workflow', inputSchema, outputSchema })
  .then(analyzeStep)
  .branch([
    {
      condition: ({ inputData }) => inputData.experienceYears > 5,
      step: seniorResumeStep,
    },
    {
      condition: ({ inputData }) => inputData.experienceYears > 2,
      step: midLevelResumeStep,
    },
    {
      condition: () => true,  // Default fallback
      step: juniorResumeStep,
    },
  ])
  .then(finalizeStep)  // Receives: { 'senior-resume' | 'mid-level' | 'junior': output }
  .commit();
```

**Primitive Discovered:**
- Method: `.branch([{ condition, step }, ...])`
- Signature: `workflow.branch(branches: Array<{ condition: (ctx) => boolean, step: Step }>)`
- Condition format: Function receiving `{ inputData }` returning boolean

**Implementation Note:**
- Only ONE branch executes (first true condition wins)
- Conditions are evaluated in order they're defined
- All steps in branch must have same input/output schema (for type safety)
- Output is keyed by executed step's ID
- Next step should use optional fields in inputSchema to handle multiple possible branches

**Additional Control Flow:**
- `.dountil(step, { condition })` - Repeat until condition is true
- `.dowhile(step, { condition })` - Repeat while condition is true
- `.foreach(step, { concurrency: 3 })` - Iterate over array input

**Source:** [Mastra Control Flow](https://mastra.ai/docs/workflows/control-flow) 

---

### RQ-7: How are errors handled?

**Why It Matters:** PR-11 (Error Handling) - When a Composio tool fails, users need to see which step failed and why.

**Status:** âœ… Answered

**Questions:**
1. How do we catch errors from a step?
2. What error object/type is thrown?
3. Can we retry a failed step without re-running the whole workflow?
4. Can we set timeouts per step?

**Answer:**
```typescript
// 1. Workflow-level retry config (applies to all steps)
const workflow = createWorkflow({
  id: 'my-workflow',
  inputSchema,
  outputSchema,
  retryConfig: {
    maxRetries: 3,
    backoff: 'exponential',
  },
});

// 2. Step-level retry config (overrides workflow-level)
const riskyStep = createStep({
  id: 'risky-step',
  inputSchema,
  outputSchema,
  retries: {
    maxRetries: 5,
    backoff: 'linear',
  },
  execute: async ({ inputData }) => { ... },
});

// 3. Early exit with success using bail()
execute: async ({ inputData, bail }) => {
  if (inputData.alreadyProcessed) {
    return bail({ status: 'skipped', reason: 'Already processed' });
  }
  // Continue with processing...
};

// 4. Early exit with error
execute: async ({ inputData }) => {
  if (!inputData.isValid) {
    throw new Error('Invalid input data');
  }
};

// 5. Monitor errors with watch()
const run = await workflow.createRunAsync();
run.watch((event) => {
  if (event.type === 'error') {
    console.error(`Step ${event.stepId} failed:`, event.error);
  }
});

// 6. Check previous step results in branching
.branch([
  {
    condition: ({ getStepResult }) => {
      const result = getStepResult('previous-step');
      return result.status === 'failed';
    },
    step: errorRecoveryStep,
  },
]);
```

**Primitives Discovered:**
- Error catching: `watch()` on workflow run, `.branch()` for conditional handling
- Error type: Standard JavaScript `Error` objects
- Retry mechanism: `retryConfig` (workflow) or `retries` (step-level)
- Timeout config: Not explicitly documented, may need to handle in execute function
- Early exit: `bail(payload)` for success, `throw new Error()` for failure

**Implementation Note:**
- Retries are built-in - great for transient Composio API failures
- Step-level config overrides workflow-level
- `getStepResult()` can check previous step status for conditional error handling
- For our testing suite: Monitor via `watch()` or `stream()` to get step-by-step results

**Source:** [Mastra Error Handling](https://mastra.ai/docs/workflows/error-handling) 

---

### RQ-8: How do we execute a workflow?

**Why It Matters:** PR-10 (Testing) - Need to run workflow with test inputs and see step-by-step results.

**Status:** âœ… Answered

**Questions:**
1. What method executes a workflow?
2. How do we pass inputs?
3. Can we get step-by-step results (not just final output)?

**Answer:**
```typescript
// Option 1: Start (wait for completion)
const run = await myWorkflow.createRunAsync();
const result = await run.start({
  inputData: {
    jobUrl: 'https://example.com/job/123',
    userId: 'user-456',
  },
});
// result.status: 'running' | 'suspended' | 'success' | 'failed'
// result.result: final output if success
// result.steps: { [stepId]: { status, output } }

// Option 2: Stream (real-time step events)
const run = await myWorkflow.createRunAsync();
for await (const event of run.stream({
  inputData: { jobUrl: '...', userId: '...' },
})) {
  console.log(event);
  // event.type: 'step-start' | 'step-complete' | 'step-error' | ...
  // event.stepId: which step
  // event.data: step output or error
}

// Workflow output structure (from start())
{
  status: 'success',
  result: { resumeId: 'r-123', status: 'generated' },
  steps: {
    'fetch-job': { status: 'success', output: { title: '...', company: '...' } },
    'analyze-requirements': { status: 'success', output: { skills: [...] } },
    'generate-resume': { status: 'success', output: { resumeId: 'r-123' } },
  }
}
```

**Primitives Discovered:**
- Execution method: `workflow.createRunAsync()` then `.start()` or `.stream()`
- Input passing: `{ inputData: {...} }` matching workflow's `inputSchema`
- Step results access: 
  - `.start()` returns full lifecycle with `steps` object
  - `.stream()` emits events as each step executes

**Implementation Note:**
- **Perfect for our testing suite**: `.stream()` gives real-time step-by-step visibility
- Workflow statuses: `running`, `suspended`, `success`, `failed`
- Each step has its own status and output in the result
- Also supports `restart()` and `restartAllActiveWorkflowRuns()` for recovery

**Source:** [Mastra Workflows Overview](https://mastra.ai/docs/workflows/overview) 

---

### RQ-8.5: How do we access non-sequential step outputs?

**Why It Matters:** PR-9 (Data Mapping) - Sometimes Step C needs data from Step A (not just Step B).

**Status:** âœ… Answered

**Question:** If Step A â†’ Step B â†’ Step C, how does Step C access Step A's output directly?

**Answer:**
Use `getStepResult(stepId)` inside `.map()` to access ANY previous step's output:

```typescript
const workflow = createWorkflow({ id: 'example', inputSchema, outputSchema })
  .then(stepA)  // Returns { company: "Acme", salary: 100000 }
  .then(stepB)  // Returns { formatted: "..." }
  .map(({ getStepResult }) => {
    // Access ANY previous step's output, not just the immediate predecessor
    const stepAResult = getStepResult('step-a');
    const stepBResult = getStepResult('step-b');
    
    return {
      company: stepAResult.company,       // From step A (non-sequential!)
      formatted: stepBResult.formatted,   // From step B
    };
  })
  .then(stepC)  // Receives the merged object
  .commit();
```

**Primitive Discovered:**
- Function: `getStepResult(stepId: string)`
- Location: Available in `.map()` callback and `execute()` function
- Returns: The output object from any previously executed step

**Implementation Note:**
- **Key for data mapping**: User draws line from Step A â†’ Step C in editor
- We code-gen a `.map()` before Step C that uses `getStepResult('step-a')` 
- Can merge outputs from multiple previous steps into a single object
- Also available: `getInitData()` to access original workflow input

**Source:** [Mastra Control Flow - Input data mapping](https://mastra.ai/docs/workflows/control-flow)

---

### RQ-8.6: Can we terminate a running workflow?

**Why It Matters:** PR-10 (Testing), UX - Users should be able to cancel a workflow mid-execution.

**Status:** ðŸ” Partially Answered

**Question:** Is there a way to cancel/abort a workflow that's currently running?

**Answer:**
Mastra provides **suspend/resume** but not explicit **cancel** in the documented API.

```typescript
// Suspend a workflow (e.g., waiting for human approval)
execute: async ({ inputData, suspend }) => {
  if (needsApproval) {
    return suspend({ reason: 'Awaiting approval' });
  }
  // continue...
};

// Resume later
await run.resume({ resumeData: { approved: true } });

// Workflow states
// 'running' | 'suspended' | 'success' | 'failed'
```

**For cancellation:**
- No explicit `cancel()` method documented
- **Workaround**: We can implement at our layer:
  1. Track running workflows by ID
  2. Use AbortController pattern in execute functions
  3. Set a "cancelled" flag that steps check before proceeding

**Implementation Note:**
- For MVP: Don't implement cancellation - workflows complete or fail
- Future: Add `AbortController` support in our Composio step wrapper
- UI: Show "Stop" button only after researching Mastra internals more

**Source:** [Mastra Workflows Overview](https://mastra.ai/docs/workflows/overview)

---

### RQ-9: Does Mastra require code files or accept runtime definitions?

**Why It Matters:** Architecture - Determines if we code-gen `.ts` files or build workflows in memory.

**Status:** âœ… Answered

**Question:** Can we define and execute a workflow without writing to disk?

**Answer:**
Based on the API, Mastra workflows are defined programmatically using `createWorkflow()` and `createStep()`. These are standard TypeScript/JavaScript functions that return workflow and step objects.

```typescript
// Both of these work the same way - they create in-memory workflow objects
// The question is HOW we construct them:

// Option A: Pre-defined in .ts files (standard pattern)
// src/workflows/resume-generator.ts
export const resumeWorkflow = createWorkflow({...}).then(...).commit();

// Option B: Runtime construction (also works!)
function buildWorkflowFromConfig(config: WorkflowDefinition) {
  let workflow = createWorkflow({
    id: config.id,
    inputSchema: zodSchemaFromJSON(config.inputSchema),
    outputSchema: zodSchemaFromJSON(config.outputSchema),
  });
  
  for (const step of config.steps) {
    workflow = workflow.then(createStep({
      id: step.id,
      inputSchema: zodSchemaFromJSON(step.inputSchema),
      outputSchema: zodSchemaFromJSON(step.outputSchema),
      execute: buildExecuteFunction(step),
    }));
  }
  
  return workflow.commit();
}
```

**Options:**
| Option | Supported? | Notes |
|--------|------------|-------|
| Code files (`.ts`) | âœ… Yes | Standard pattern - register in Mastra instance |
| Runtime definition | âœ… Yes | Can construct dynamically from config |

**Implementation Note:**
- **Key insight**: Mastra doesn't care WHERE the workflow definition comes from
- We CAN build workflows at runtime from JSON config stored in our `_tables/workflows/`
- **HOWEVER**: Dynamic Zod schema construction is tricky
- **Recommendation**: Code-gen `.ts` files for:
  1. Type safety
  2. Easier debugging
  3. Version control
  4. Simpler architecture (no need to serialize/deserialize Zod schemas)
- Store both: `definition.json` (editor state) + `workflow.ts` (executable)

**Source:** Derived from Mastra API patterns 

---

## Part 2: Composio Research

### RQ-10: Does Composio expose output schemas?

**Why It Matters:** PR-1 (Node Discovery), PR-3 (Connection Validation) - We need to know what a tool returns to validate connections.

**Status:** âœ… Answered - **OUTPUT SCHEMAS EXIST!**

**Question:** When we fetch a tool, does it include an output schema? If not, what are our options?

**Answer:**
**CORRECTED**: Composio DOES provide output schemas via `output_parameters`!

From `@composio/client/resources/tools.d.ts` (line 110):

```typescript
export interface ToolRetrieveResponse {
  // ... other fields ...
  
  /**
   * Schema definition of required input parameters for the tool
   */
  input_parameters: {
    [key: string]: unknown;
  };
  
  /**
   * Schema definition of return values from the tool
   */
  output_parameters: {
    [key: string]: unknown;  // âœ… OUTPUT SCHEMA EXISTS!
  };
  
  // ... other fields ...
}
```

**How to access:**
```typescript
// Using the Composio client
const client = new Composio();
const toolDetails = await client.tools.retrieve('GMAIL_LIST_EMAILS');

// Both schemas available:
const inputSchema = toolDetails.input_parameters;   // âœ… Input schema
const outputSchema = toolDetails.output_parameters; // âœ… Output schema!
```

**What this means:**
| Capability | Status |
|------------|--------|
| Input schema | âœ… Available via `input_parameters` |
| Output schema | âœ… Available via `output_parameters` |
| Full type validation | âœ… Can validate connections in BOTH directions |
| Data mapping UI | âœ… Can show available output fields |

**Implementation Note:**
- **Big win**: We can convert BOTH `input_parameters` and `output_parameters` to Zod schemas
- Use our existing `jsonSchemaToZod()` helper from `composio-tools.ts`
- Connection validation (PR-3) can now work bidirectionally
- Data mapping UI can show source node's output fields when connecting
- This enables full type-safe workflows with Composio tools!

**Code pattern for workflow step creation:**
```typescript
function createComposioStep(toolDetails: ToolRetrieveResponse) {
  return createStep({
    id: `composio-${toolDetails.slug}`,
    inputSchema: jsonSchemaToZod(toolDetails.input_parameters),
    outputSchema: jsonSchemaToZod(toolDetails.output_parameters), // âœ… Now possible!
    execute: async ({ inputData, runtimeContext }) => {
      return await client.tools.execute(toolDetails.slug, {
        arguments: inputData,
        connectedAccountId: runtimeContext.get('connectionId'),
      });
    },
  });
}
```

**Source:** 
- `node_modules/@composio/client/resources/tools.d.ts` (TypeScript definitions)
- `client.tools.retrieve(toolSlug)` API method

---

### RQ-11: How do we get toolkit from tool?

**Why It Matters:** PR-4 (Connection Requirements) - When user adds a Gmail tool, we auto-detect "Requires Gmail".

**Status:** âœ… Answered

**Question:** Given a tool like `GMAIL_SEND_EMAIL`, how do we extract `gmail` as the toolkit?

**Answer:**
```typescript
// Option 1: Parse from tool ID (our current approach in connectionToolBindings)
// Tool IDs follow pattern: TOOLKIT_ACTION_NAME (e.g., GMAIL_SEND_EMAIL, GITHUB_CREATE_ISSUE)
function extractToolkit(toolId: string): string {
  // Split by underscore, first part is usually the toolkit
  const parts = toolId.split('_');
  return parts[0].toLowerCase(); // 'gmail', 'github', etc.
}

// Option 2: Use the toolkitSlug from ConnectionToolBinding (already exists!)
interface ConnectionToolBinding {
  toolId: string;           // e.g., "GMAIL_SEND_EMAIL"
  connectionId: string;     // The user's connected account
  toolkitSlug: string;      // e.g., "gmail" - ALREADY STORED!
}

// Our existing agent config already captures this:
const miraPatel: AgentConfig = {
  connectionToolBindings: [
    { toolId: "GMAIL_GET_PROFILE", connectionId: "xxx", toolkitSlug: "gmail" },
    { toolId: "GITHUB_CREATE_ISSUE", connectionId: "yyy", toolkitSlug: "github" },
  ],
};
```

**Primitive Discovered:**
- Property: `ConnectionToolBinding.toolkitSlug` (already exists in our types!)
- Or parse method: `toolId.split('_')[0].toLowerCase()`

**Implementation Note:**
- **Good news**: Our `_tables/types.ts` already has `toolkitSlug` in `ConnectionToolBinding`
- When generating connection requirements, we can:
  1. Scan all Composio nodes in workflow
  2. Extract unique `toolkitSlug` values
  3. Display as "This workflow requires: Gmail, GitHub, Slack"
- For workflow editor: When user drags in a Composio tool, we know its toolkit

**Existing Code Reference:** `app/api/tools/services/composio-tools.ts`, `_tables/types.ts`

---

### RQ-12: How do we wrap Composio tools as Mastra steps?

**Why It Matters:** PR-2 (IPO Model), PR-4 (Connection Requirements) - Core integration pattern.

**Status:** âœ… Answered

**Questions:**
1. Can Composio tools be used directly as Mastra steps?
2. How do we pass `connectionId` to the tool execution?
3. Is there an official integration?

**Answer:**
```typescript
// 1. Official Composio integration exists for Mastra agents (not workflows directly)
import { getTools } from "composio-core";

const tools = await getTools({ provider: "mastra" }); // Returns Mastra-formatted tools

// 2. For WORKFLOWS, we need to wrap Composio tools as Mastra steps:
import { createStep } from '@mastra/core/workflows';
import { z } from 'zod';

function createComposioStep(
  toolId: string, 
  toolkitSlug: string,
  inputSchema: z.ZodObject<any>
) {
  return createStep({
    id: `composio-${toolkitSlug}-${toolId.toLowerCase()}`,
    inputSchema,
    outputSchema: z.any(), // Composio doesn't provide output schemas
    execute: async ({ inputData, runtimeContext }) => {
      const client = getComposioClient();
      
      // Get connectionId from runtime context (user-specific)
      const connectionId = runtimeContext?.get('connections')?.[toolkitSlug];
      
      const result = await client.tools.execute(toolId, {
        userId: runtimeContext?.get('userId'),
        arguments: inputData,
        connectedAccountId: connectionId, // Key: User's specific connection
        dangerouslySkipVersionCheck: true,
      });
      
      return result;
    },
  });
}

// 3. Usage in workflow
const workflow = createWorkflow({ id: 'email-workflow', inputSchema, outputSchema })
  .then(createComposioStep('GMAIL_SEND_EMAIL', 'gmail', z.object({
    recipient: z.string(),
    subject: z.string(),
    body: z.string(),
  })))
  .commit();
```

**Integration Pattern:**
```typescript
// Pattern for our workflow editor:
// 1. User drags Composio tool node onto canvas
// 2. We fetch tool metadata from Composio (name, description, inputSchema)
// 3. We code-gen a createStep() wrapper with:
//    - inputSchema from Composio
//    - outputSchema as z.any()
//    - execute that calls client.tools.execute()
// 4. connectionId comes from RuntimeContext at execution time
```

**Implementation Note:**
- **Official integration**: `composio-core` has `getTools({ provider: "mastra" })` for AGENTS
- **For workflows**: We wrap Composio tools as Mastra steps manually
- **Key insight**: `connectionId` must come from runtime context (user who hired the agent)
- Our existing `composio-tools.ts` already has the execution pattern - just need to adapt for `createStep()`

**Source:** [Composio Mastra Integration](https://docs.composio.dev/providers/mastra) + our `composio-tools.ts`

---

## Part 3: Architectural Decisions

These are **decisions we make**, not facts to discover. Document the decision and rationale.

### OQ-1: Code-Gen vs Runtime Interpretation

**Decision:** âœ… **Code-Gen** (decided based on RQ-9)

**Options:**
| Option | When to Choose |
|--------|----------------|
| Code-Gen | If Mastra requires files, or we want inspectable/versionable workflows |
| Runtime | If Mastra supports it and we want faster iteration |

**Our Decision:** **Code-Gen `.ts` files**

**Rationale:**
1. **Type safety**: Zod schemas are hard to serialize/deserialize; code-gen keeps TypeScript happy
2. **Debugging**: Developers can inspect generated workflow code
3. **Version control**: Workflow changes are tracked in git
4. **Simpler architecture**: No need for runtime Zod schema construction
5. **Alignment with Mastra patterns**: Mastra examples all use `.ts` files

**Storage pattern:**
```
_tables/workflows/{workflowId}/
  â”œâ”€â”€ definition.json    # Editor state (nodes, edges, configs)
  â””â”€â”€ workflow.ts        # Generated Mastra workflow code
```


---

### OQ-2: How to handle output schema validation?

**Decision:** âœ… **UPDATED - Full validation now possible!** (corrected based on RQ-10 finding)

**Previous understanding:** We thought Composio didn't expose output schemas.

**Corrected understanding:** Composio DOES provide `output_parameters` via `client.tools.retrieve()`.

**Our Updated Decision:** **Full bidirectional validation for all nodes**

**Rationale:**
1. **Output schemas exist**: `output_parameters` is available in `ToolRetrieveResponse`
2. **Type safety throughout**: We can validate connections in BOTH directions
3. **Better UX**: Data mapping UI can show available output fields
4. **Unified pattern**: Both Composio tools and custom steps have full schemas

**Implementation:**
- Fetch tool with `client.tools.retrieve(toolSlug)`
- Convert `input_parameters` â†’ Zod schema for step input
- Convert `output_parameters` â†’ Zod schema for step output
- Connection validation checks outputâ†’input type compatibility
- UI shows actual output field names when connecting nodes

**Code pattern:**
```typescript
const toolDetails = await client.tools.retrieve(toolSlug);
const step = createStep({
  id: `composio-${toolSlug}`,
  inputSchema: jsonSchemaToZod(toolDetails.input_parameters),
  outputSchema: jsonSchemaToZod(toolDetails.output_parameters), // âœ… Full schema!
  execute: async ({ inputData }) => { ... },
});
```


---

### OQ-3: Data transforms in mappings?

**Question:** Do we support inline transforms (e.g., `salary.min + "-" + salary.max`), or just direct field mapping?

**Options:**
| Option | Complexity | User Power |
|--------|------------|------------|
| Direct mapping only | Low | Low - use Code nodes for transforms |
| Simple transforms | Medium | Medium - basic operations |
| Full expressions | High | High - but complex to build |

**Our Decision:** **Direct mapping + Code nodes for transforms**

**Rationale:**
1. **Keep it simple**: Direct field mapping covers 80% of use cases
2. **Mastra has `.map()` with helpers**: `getStepResult()`, `mapVariable()` are powerful enough
3. **Code nodes exist**: For complex transforms, users can add a custom code step
4. **Avoid expression language**: Building/debugging a custom expression DSL is expensive
5. **Type safety**: Direct mapping is easier to validate at design time

**Implementation in UI:**
```
[Node A Output]           [Node B Input]
  title      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   jobTitle        (rename mapping)
  company    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   companyName     (rename mapping)
  salary.min â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º   minSalary       (nested path)

For transforms: Insert a "Code" node between
```

**Generated code:**
```typescript
.map(({ inputData }) => ({
  jobTitle: inputData.title,
  companyName: inputData.company,
  minSalary: inputData.salary.min,
}))
```


---

## Part 4: Summary & Action Items

### Primitives We'll Use

| What | Primitive | From |
|------|-----------|------|
| Define workflow | `createWorkflow({ id, inputSchema, outputSchema })` | Mastra âœ… |
| Define step | `createStep({ id, inputSchema, outputSchema, execute })` | Mastra âœ… |
| Chain steps | `.then(step)`, `.parallel([])`, `.branch([])` | Mastra âœ… |
| Data mapping | `.map(({ inputData, getStepResult, mapVariable }) => ...)` | Mastra âœ… |
| Error handling | `retryConfig`, `retries`, `bail()`, `throw Error` | Mastra âœ… |
| Execute workflow | `workflow.createRunAsync().start({ inputData })` | Mastra âœ… |
| Stream results | `workflow.createRunAsync().stream({ inputData })` | Mastra âœ… |
| Fetch tools | `getToolAction(userId, toolId)` | Composio âœ… |
| Get input schema | `tool.input_parameters` (JSON Schema) | Composio âœ… |
| Get output schema | `tool.output_parameters` (JSON Schema) | Composio âœ… |
| Execute tool | `client.tools.execute(toolId, { userId, arguments, connectedAccountId })` | Composio âœ… |
| Get toolkit | `ConnectionToolBinding.toolkitSlug` | Our types âœ… |

### Key Decisions Made

| Decision | Choice | Date |
|----------|--------|------|
| Code-Gen vs Runtime | **Code-Gen `.ts` files** | 2025-12-06 |
| Output schema handling | **Full validation** - Composio provides `output_parameters` | 2025-12-06 (corrected) |
| Data transforms | **Direct mapping + Code nodes** | 2025-12-06 |
| Hybrid execution | **Code-gen on save, runtime for testing** | 2025-12-06 |

### Blockers & Issues

| Issue | Impact | Resolution |
|-------|--------|------------|
| ~~Composio lacks output schemas~~ | ~~Can't validate output connections~~ | **RESOLVED** - `output_parameters` exists! |
| `@composio/mastra` version mismatch | Can't use official package directly | Use our manual wrapper (already exists) |

### Ready to Proceed?

- [x] All RQ questions answered (12/12)
- [x] All OQ decisions made (3/3)
- [x] No critical blockers
- [x] Summary table complete

**Next Step:** Phase 1 (UXD Mockups) - Create high-fidelity mockups for:
1. Tool Palette with Composio nodes
2. Canvas with IPO visualization
3. Data mapping drawer
4. Connection requirements panel
5. Test runner UI
