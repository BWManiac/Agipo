# Task 15.11: Workflows F - Greenfield Implementation Plan

**Status:** Planning  
**Date:** December 2025  
**Approach:** Build from scratch, learn from A-E  
**Philosophy:** Clean slate with lessons learned

---

## Executive Summary

After 5 implementation attempts (A through E), we've learned what works and what doesn't. **Workflows F** will be a fresh start that:

1. âœ… **Takes the best patterns** from previous implementations
2. âœ… **Avoids the mistakes** we've identified
3. âœ… **Starts with clean architecture** from day one
4. âœ… **Implements incrementally** with clear phases

**Why Greenfield?**
- Avoid technical debt from copy-paste
- Clean architecture decisions from the start
- No legacy patterns to work around
- Can implement best practices from the beginning

---

## Part 1: Lessons Learned (What to Keep)

### âœ… What Worked Well

#### From Workflows A
1. **Code Generator Pattern**
   - Clean separation: JSON â†’ TypeScript
   - Handles all step types properly
   - Connection/table placeholder system
   - **Keep:** Generator structure and approach

2. **Execution Service Pattern**
   - Runtime interpretation for testing
   - Step-by-step progress tracking
   - Proper error handling
   - **Keep:** Execution service architecture

3. **Component Organization**
   - Clear separation: canvas/, list/, inspector/, panels/
   - Reusable components
   - **Keep:** Component structure

#### From Workflows C
1. **Command Palette**
   - Cmd+K interface is powerful
   - Quick actions improve UX
   - **Keep:** Command palette concept

2. **Code Preview**
   - Live preview of generated code
   - Helps users understand what they're building
   - **Keep:** Code preview feature

#### From Workflows D
1. **Undo/Redo**
   - Essential for complex workflows
   - Users make mistakes, need to recover
   - **Keep:** Undo/redo functionality

2. **Keyboard Shortcuts**
   - Power users love keyboard navigation
   - **Keep:** Comprehensive shortcuts

#### From Workflows E
1. **Planning First**
   - Comprehensive planning docs saved time
   - Clear acceptance criteria
   - **Keep:** Planning methodology

2. **Store Architecture**
   - Clean slice separation
   - Type safety throughout
   - **Keep:** Store pattern

---

## Part 2: Mistakes to Avoid

### âŒ What Didn't Work Well

1. **Inconsistent Type Systems**
   - A uses `workflows/services/types.ts`
   - E re-exports from base
   - B has custom types in `_tables/`
   - **Avoid:** Multiple type systems
   - **Do:** Single source of truth for types

2. **Copy-Paste Storage Services**
   - A, D, E all have nearly identical storage.ts
   - **Avoid:** Duplicating code
   - **Do:** Shared service or proper abstraction

3. **Incomplete Implementations**
   - Many implementations missing key features
   - **Avoid:** Starting too many variations
   - **Do:** Complete one implementation fully

4. **No Clear Migration Path**
   - Hard to consolidate implementations
   - **Avoid:** Creating parallel implementations
   - **Do:** Plan consolidation from the start

5. **Inconsistent Naming**
   - Some use `workflowId`, others use `id`
   - **Avoid:** Inconsistent naming
   - **Do:** Establish naming conventions early

---

## Part 3: Workflows F Architecture Principles

### Core Principles

1. **Single Source of Truth**
   - One type system (`app/api/workflows-f/services/types.ts`)
   - One storage service (no duplication)
   - One store architecture

2. **Incremental Implementation**
   - Phase 1: Foundation (types, storage, basic UI)
   - Phase 2: Core features (steps, mappings)
   - Phase 3: Advanced features (testing, code gen)
   - Phase 4: Polish (undo/redo, shortcuts)

3. **Best Practices from Day One**
   - Error boundaries everywhere
   - Loading states for all async operations
   - Type safety throughout
   - Proper error handling

4. **Learn from Others, Don't Copy**
   - Study A's generator, write F's version
   - Study C's command palette, write F's version
   - Study D's undo/redo, write F's version
   - **Don't copy-paste** - rewrite with lessons learned

---

## Part 4: Workflows F File Structure

```
app/(pages)/workflows-f/
â”œâ”€â”€ page.tsx                    # List page
â””â”€â”€ editor/
    â”œâ”€â”€ page.tsx                 # Main editor
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ layout/
    â”‚   â”‚   â”œâ”€â”€ EditorLayout.tsx
    â”‚   â”‚   â”œâ”€â”€ EditorHeader.tsx
    â”‚   â”‚   â”œâ”€â”€ EditorSidebar.tsx
    â”‚   â”‚   â””â”€â”€ EditorInspector.tsx
    â”‚   â”œâ”€â”€ views/
    â”‚   â”‚   â”œâ”€â”€ ListView.tsx
    â”‚   â”‚   â””â”€â”€ CanvasView.tsx
    â”‚   â”œâ”€â”€ steps/
    â”‚   â”‚   â”œâ”€â”€ StepCard.tsx
    â”‚   â”‚   â”œâ”€â”€ StepNode.tsx
    â”‚   â”‚   â””â”€â”€ StepInspector.tsx
    â”‚   â”œâ”€â”€ panels/
    â”‚   â”‚   â”œâ”€â”€ ToolPalette.tsx
    â”‚   â”‚   â”œâ”€â”€ InputsPanel.tsx
    â”‚   â”‚   â”œâ”€â”€ ConfigPanel.tsx
    â”‚   â”‚   â”œâ”€â”€ ConnectionsPanel.tsx
    â”‚   â”‚   â”œâ”€â”€ TestPanel.tsx
    â”‚   â”‚   â””â”€â”€ TablesPanel.tsx
    â”‚   â”œâ”€â”€ features/
    â”‚   â”‚   â”œâ”€â”€ CommandPalette.tsx
    â”‚   â”‚   â”œâ”€â”€ CodePreview.tsx
    â”‚   â”‚   â””â”€â”€ DataMappingModal.tsx
    â”‚   â””â”€â”€ common/
    â”‚       â”œâ”€â”€ ErrorBoundary.tsx
    â”‚       â””â”€â”€ LoadingState.tsx
    â”œâ”€â”€ hooks/
    â”‚   â”œâ”€â”€ useWorkflowLoader.ts
    â”‚   â”œâ”€â”€ usePersistence.ts
    â”‚   â”œâ”€â”€ useUndoRedo.ts
    â”‚   â”œâ”€â”€ useKeyboardShortcuts.ts
    â”‚   â””â”€â”€ useComposioTools.ts
    â””â”€â”€ store/
        â”œâ”€â”€ index.ts
        â”œâ”€â”€ types.ts
        â””â”€â”€ slices/
            â”œâ”€â”€ workflowSlice.ts
            â”œâ”€â”€ stepsSlice.ts
            â”œâ”€â”€ mappingsSlice.ts
            â”œâ”€â”€ uiSlice.ts
            â”œâ”€â”€ inputsSlice.ts
            â”œâ”€â”€ connectionsSlice.ts
            â”œâ”€â”€ tablesSlice.ts
            â””â”€â”€ testingSlice.ts

app/api/workflows-f/
â”œâ”€â”€ create/route.ts
â”œâ”€â”€ list/route.ts
â”œâ”€â”€ [workflowId]/
â”‚   â”œâ”€â”€ route.ts
â”‚   â”œâ”€â”€ execute/route.ts
â”‚   â””â”€â”€ generate/route.ts
â””â”€â”€ services/
    â”œâ”€â”€ index.ts
    â”œâ”€â”€ types.ts
    â”œâ”€â”€ storage.ts
    â”œâ”€â”€ generator.ts
    â””â”€â”€ executor.ts

_tables/workflows-f/
â””â”€â”€ [workflowId]/
    â”œâ”€â”€ workflow.json
    â””â”€â”€ workflow.ts
```

**Key Differences from Previous:**
- Clear `views/` folder (not mixed with components)
- `features/` folder for unique features (command palette, etc.)
- `layout/` folder for layout components
- Consistent naming throughout

---

## Part 5: Implementation Phases

### Phase 1: Foundation (Week 1)

**Goal:** Solid foundation with types, storage, and basic UI

**Tasks:**
1. Create folder structure
2. Define types (`services/types.ts`)
3. Implement storage service (`services/storage.ts`)
4. Create basic API routes (create, list, get)
5. Set up store architecture (all slices)
6. Create basic editor layout (header, sidebar, main, inspector)
7. Add navigation entry

**Deliverables:**
- âœ… Can create a workflow
- âœ… Can list workflows
- âœ… Can open workflow in editor
- âœ… Basic layout renders
- âœ… Store initializes correctly

**Lines of Code:** ~1,500

---

### Phase 2: Core Features (Week 2)

**Goal:** Add steps, basic UI, and tool palette

**Tasks:**
1. Implement ToolPalette component
2. Implement ListView (step timeline)
3. Implement StepCard component
4. Add step management (add, remove, reorder)
5. Implement StepInspector
6. Add basic data flow visualization

**Deliverables:**
- âœ… Can add steps from tool palette
- âœ… Can see steps in list view
- âœ… Can select and inspect steps
- âœ… Can reorder steps
- âœ… Can delete steps

**Lines of Code:** ~2,000

---

### Phase 3: Data Mapping (Week 3)

**Goal:** Connect steps with data mappings

**Tasks:**
1. Implement DataMappingModal
2. Add mapping UI in inspector
3. Implement type validation
4. Add nested field access
5. Visualize mappings in list view

**Deliverables:**
- âœ… Can create mappings between steps
- âœ… Type validation works
- âœ… Nested paths work
- âœ… Mappings visible in UI

**Lines of Code:** ~1,500

---

### Phase 4: Code Generation & Execution (Week 4)

**Goal:** Generate Mastra code and test workflows

**Tasks:**
1. Implement code generator (`services/generator.ts`)
2. Implement execution service (`services/executor.ts`)
3. Add TestPanel component
4. Add code preview feature
5. Implement step-by-step execution

**Deliverables:**
- âœ… Can generate workflow.ts
- âœ… Can test workflows
- âœ… See step-by-step progress
- âœ… See generated code preview

**Lines of Code:** ~2,000

---

### Phase 5: Advanced Features (Week 5)

**Goal:** Add power-user features

**Tasks:**
1. Implement CommandPalette
2. Implement undo/redo
3. Add keyboard shortcuts
4. Implement CanvasView (ReactFlow)
5. Add abstraction levels (Flow/Spec/Code)

**Deliverables:**
- âœ… Command palette works (Cmd+K)
- âœ… Undo/redo works
- âœ… Keyboard shortcuts work
- âœ… Canvas view works
- âœ… Can switch abstraction levels

**Lines of Code:** ~2,500

---

### Phase 6: Polish & Integration (Week 6)

**Goal:** Final polish and agent integration

**Tasks:**
1. Error handling throughout
2. Loading states everywhere
3. Empty states
4. Agent integration
5. Final styling pass

**Deliverables:**
- âœ… All error cases handled
- âœ… All loading states implemented
- âœ… Agents can use workflows
- âœ… Production ready

**Lines of Code:** ~1,500

**Total Estimated:** ~11,000 lines (cleaner than A's 6,053 because we're not copying legacy code)

---

## Part 6: Key Decisions for F

### Decision 1: Type System

**Choice:** Single source of truth in `app/api/workflows-f/services/types.ts`

**Rationale:**
- Avoids duplication
- Easy to maintain
- Clear ownership

**Implementation:**
```typescript
// Single file with all types
export interface WorkflowDefinition { ... }
export interface WorkflowStep { ... }
// etc.
```

---

### Decision 2: Storage Service

**Choice:** One storage service, no duplication

**Rationale:**
- Previous implementations all had identical storage.ts
- No need to duplicate

**Implementation:**
```typescript
// app/api/workflows-f/services/storage.ts
// Clean, well-documented, handles all cases
```

---

### Decision 3: Code Generation Strategy

**Choice:** Study A's generator, write F's version from scratch

**Rationale:**
- A's generator is good but has some quirks
- Can improve with lessons learned
- Cleaner code without legacy patterns

**Key Improvements:**
- Better error messages
- More maintainable structure
- Better handling of edge cases

---

### Decision 4: Store Architecture

**Choice:** Use E's slice pattern (proven to work)

**Rationale:**
- E has best store structure
- Clean separation of concerns
- Easy to extend

**Implementation:**
```typescript
// 8 slices: workflow, steps, mappings, UI, inputs, connections, tables, testing
// Same pattern as E, but written fresh
```

---

### Decision 5: Component Organization

**Choice:** Clear folder structure (views/, features/, panels/, etc.)

**Rationale:**
- Previous implementations mixed concerns
- Clear organization makes maintenance easier

**Structure:**
- `layout/` - Layout components
- `views/` - List and Canvas views
- `steps/` - Step-related components
- `panels/` - Right sidebar panels
- `features/` - Unique features (command palette, etc.)
- `common/` - Shared components

---

## Part 7: What to Study (Not Copy)

### Study These Files

1. **Code Generator** - `app/api/workflows/services/generator.ts`
   - Study: How it handles step types
   - Study: Mapping generation logic
   - Study: Connection/table placeholders
   - **Don't copy:** Write F's version with improvements

2. **Execution Service** - `app/api/workflows/services/execution.ts`
   - Study: Runtime interpretation approach
   - Study: Step-by-step tracking
   - Study: Error handling
   - **Don't copy:** Write F's version with improvements

3. **Command Palette** - `app/(pages)/workflows-c/editor/components/CommandPalette.tsx`
   - Study: UI/UX pattern
   - Study: Command structure
   - **Don't copy:** Write F's version with better integration

4. **Undo/Redo** - `app/(pages)/workflows-d/editor/hooks/useUndoRedo.ts`
   - Study: History management
   - Study: State tracking
   - **Don't copy:** Write F's version integrated with store

5. **Store Slices** - `app/(pages)/workflows-e/editor/store/slices/`
   - Study: Slice organization
   - Study: Action patterns
   - **Don't copy:** Write F's version with improvements

---

## Part 8: Success Criteria

### Phase 1 Success
- [ ] Can create workflow
- [ ] Can list workflows
- [ ] Editor opens with basic layout
- [ ] Store initializes correctly

### Phase 2 Success
- [ ] Can add steps
- [ ] Can see steps in list
- [ ] Can inspect steps
- [ ] Can reorder/delete steps

### Phase 3 Success
- [ ] Can create data mappings
- [ ] Type validation works
- [ ] Mappings visible in UI

### Phase 4 Success
- [ ] Code generation works
- [ ] Can test workflows
- [ ] Step-by-step execution works

### Phase 5 Success
- [ ] Command palette works
- [ ] Undo/redo works
- [ ] Canvas view works
- [ ] All features integrated

### Phase 6 Success
- [ ] All 81 acceptance criteria met
- [ ] Production ready
- [ ] Agents can use workflows

---

## Part 9: Advantages of Greenfield Approach

1. **No Technical Debt**
   - Start with clean code
   - No legacy patterns to work around
   - Modern best practices from day one

2. **Better Architecture**
   - Can design with all lessons learned
   - No compromises from existing code
   - Clean separation of concerns

3. **Easier Maintenance**
   - Consistent patterns throughout
   - No mixed styles
   - Clear ownership

4. **Faster Development**
   - No time spent adapting old code
   - Can implement features correctly the first time
   - Less debugging of legacy issues

5. **Team Understanding**
   - Everyone understands the codebase
   - No "why did we do it this way?" moments
   - Clear documentation from the start

---

## Part 10: Risks & Mitigation

### Risk 1: Repeating Mistakes

**Risk:** Might make same mistakes as A-E

**Mitigation:**
- Document lessons learned (this doc)
- Code review against lessons learned
- Regular check-ins: "Are we repeating a mistake?"

### Risk 2: Missing Features

**Risk:** Might forget to implement something from A-E

**Mitigation:**
- Feature checklist from analysis (15.9)
- Acceptance criteria from 15-workflow-editor.md
- Regular comparison: "Does F have everything A has?"

### Risk 3: Taking Too Long

**Risk:** Greenfield might take longer than migration

**Mitigation:**
- Phased approach (can ship after each phase)
- Study existing code (don't reinvent)
- Focus on MVP first, polish later

---

## Part 11: Next Steps

1. **âœ… Decision Made:** Build Workflows F from scratch
2. **ğŸ“‹ Create:** Folder structure
3. **ğŸ“ Document:** Lessons learned reference (this doc)
4. **ğŸš€ Start:** Phase 1 - Foundation
5. **ğŸ“Š Track:** Progress against phases

---

## Conclusion

**Building Workflows F from scratch is the right call.**

**Why:**
- âœ… 5 implementations taught us what works
- âœ… Clean slate = better architecture
- âœ… Can implement best practices from day one
- âœ… Avoid technical debt
- âœ… Faster long-term (less debugging)

**How:**
- Study A-E for patterns (don't copy)
- Implement incrementally (phases)
- Focus on quality over speed
- Learn from mistakes (document them)

**Result:**
- Clean, maintainable codebase
- All features from A-E (best versions)
- Unique features (abstraction levels, etc.)
- Production-ready in 6 weeks

---

**Ready to start Phase 1?** ğŸš€

