# Task 15.6: Workflows E - Deep Understanding & Implementation Plan

**Status:** Research & Planning  
**Date:** December 2025  
**Variation:** E (Fifth implementation variation)  
**Goal:** Demonstrate comprehensive understanding before implementation

---

## Executive Summary

This document demonstrates deep understanding of:
1. **All 81 acceptance criteria** across 15 categories
2. **12 product requirements** (PR-1 through PR-12)
3. **Technical architecture** (Mastra primitives, Composio integration, data model)
4. **Implementation pattern** (Variations A, B, C, D → E)
5. **What makes Variation E unique** (based on Flight C Variation B mockup)

**Variation E will be implemented in:**
- `app/(pages)/workflows-e/` (frontend)
- `app/api/workflows-e/` (backend API)
- `_tables/workflows-e/` (storage)

---

## Part 1: Product Requirements Deep Dive

### PR-1: Composio Node Discovery

**What it means:** Users must see all available Composio tools as draggable/clickable nodes in a palette, with full schema visibility.

**Technical Requirements:**
- Fetch tools from `getRawComposioTools()` (existing service)
- Display `input_parameters` (JSON Schema) → converted to Zod for validation
- Display `output_parameters` (JSON Schema) → **VERIFIED EXISTS** (RQ-10)
- Group by `toolkit.slug` (Gmail, GitHub, Firecrawl, etc.)
- Show NO_AUTH tools (browser_tool) available to all users
- Search/filter by tool name

**Acceptance Criteria Mapping:**
- AC-1.1: Palette displays Composio tools from connected integrations
- AC-1.2: Palette displays NO_AUTH tools
- AC-1.3: Each tool shows input schema
- AC-1.4: Each tool shows output schema
- AC-1.5: Tools grouped by toolkit
- AC-1.6: Tools searchable by name
- AC-1.7: Drag/click tool creates node

**Implementation Notes:**
- Use existing `app/api/tools/services/composio-tools.ts` patterns
- Cache tool schemas in workflow.json to avoid repeated API calls
- Handle missing `output_parameters` with `z.record(z.string(), z.any())` fallback

---

### PR-2: Input-Process-Output (IPO) Model

**What it means:** Every node has three parts: Input (what it receives), Process (what it does), Output (what it produces). This is the mental model for the entire editor.

**Technical Requirements:**
- Each `WorkflowStep` has `inputSchema` and `outputSchema` (JSON Schema format)
- Display schemas in node UI (both list and canvas views)
- Terminal nodes (no downstream) don't need output validation
- Node inspector shows full I/O details

**Acceptance Criteria Mapping:**
- AC-2.1: Each node displays input schema
- AC-2.2: Each node displays output schema (or "unknown" indicator)
- AC-2.3: Nodes connect via edges
- AC-2.4: Clicking edge opens data mapping UI
- AC-2.5: Terminal nodes display correctly without output handles
- AC-2.6: Node inspector shows full I/O details

**Mastra Primitive Mapping:**
```typescript
// Visual node → Mastra step
createStep({
  id: "step-1",
  inputSchema: z.object({ ... }),  // From step.inputSchema (JSON → Zod)
  outputSchema: z.object({ ... }),  // From step.outputSchema (JSON → Zod)
  execute: async ({ inputData }) => { ... }
})
```

---

### PR-3: Connection Validation (Type Checking)

**What it means:** When connecting two nodes, validate that output type matches input type. Prevent runtime errors.

**Technical Requirements:**
- Validate type compatibility when user creates edge
- Show visual indicator for invalid connections (red edge, warning)
- Allow connection but warn if types are coercible (number → string)
- Block connection if types are incompatible (object → boolean)

**Type Compatibility Matrix:**
| Output Type | Can Connect To |
|-------------|---------------|
| string | string, any |
| number | number, string (coerce), any |
| boolean | boolean, string (coerce), any |
| array | array, any |
| object | object, any |
| any | any |

**Acceptance Criteria Mapping:**
- AC-3.1: Type validation runs when creating edge
- AC-3.2: Invalid connections show visual indicator (red edge)
- AC-3.3: Coercible types show warning but allow connection
- AC-3.4: Incompatible types block connection or show error

**Implementation Notes:**
- Use JSON Schema type comparison
- Store `typeMatch` in `FieldMapping` ("exact" | "coercible" | "incompatible")
- Visual feedback: green edge (exact), yellow edge (coercible), red edge (incompatible)

---

### PR-4: Connection Requirements (Composio Auth)

**What it means:** Workflows declare what Composio integrations they need. Auto-detect from tool nodes used.

**Technical Requirements:**
- Auto-detect required connections from tool nodes
- Display in Connections panel
- Validate when assigning to agent
- Block execution if connections missing

**How auto-detection works:**
1. User adds Gmail tool node → workflow now requires Gmail
2. User adds GitHub tool node → workflow now requires GitHub
3. Editor shows: "This workflow requires: Gmail, GitHub"

**Acceptance Criteria Mapping:**
- AC-4.1: Adding tool node auto-detects required connection
- AC-4.2: Required connections displayed in Connections panel
- AC-4.3: When assigning to agent, validate required connections exist
- AC-4.4: Block execution if connections missing

**Technical Implementation:**
- Extract `toolkitSlug` from `WorkflowStep.toolkitSlug`
- Store in `WorkflowDefinition.connections` as `{ [toolkitSlug]: connectionId | null }`
- NO_AUTH tools don't require connections

---

### PR-5: Configs (User-Settable Values)

**What it means:** Values that workflow author defines, and workflow user sets when assigning to an agent. Persist across executions.

**Technical Requirements:**
- Author can define configs (name, type, required, default)
- Node parameters can reference configs: `{{configs.targetRepo}}`
- When assigning workflow to agent, user provides config values
- Config values stored per agent-workflow binding
- Config types: text, number, boolean, select (dropdown)

**Example:**
```
Workflow: "Update README on PR"
Configs:
  - targetRepo: string (required)
  - targetPath: string (default: "/README.md")
  - tone: select ["technical", "casual"] (default: "technical")
```

**Acceptance Criteria Mapping:**
- AC-5.1: Author can define configs (name, type, required, default)
- AC-5.2: Node parameters can reference configs via `{{configs.x}}`
- AC-5.3: Config values requested when assigning workflow to agent
- AC-5.4: Config values stored per agent-workflow binding
- AC-5.5: Supported config types: text, number, boolean, select

**Data Model:**
```typescript
interface WorkflowConfig {
  key: string;           // "targetRepo"
  type: "text" | "number" | "boolean" | "select";
  label: string;         // "Target Repository"
  description?: string;
  required: boolean;
  options?: string[];     // For select type
  default?: unknown;
}
```

---

### PR-6: Control Flow Nodes

**What it means:** Nodes that control execution flow (branching, looping, parallel execution).

**Technical Requirements:**
- Branch node: if/else based on condition
- Parallel node: run multiple paths simultaneously
- Loop node: repeat until condition met (P2)
- Wait node: pause for human approval (P2)

**Mastra Primitive Mapping:**
```typescript
// Branch
.branch([
  [async ({ inputData }) => inputData.priority === "high", urgentStep],
  [async () => true, defaultStep],
])

// Parallel
.parallel([stepA, stepB, stepC])
// Output: { stepA: {...}, stepB: {...}, stepC: {...} }

// Loop (P2)
.dowhile(step, condition)
.dountil(step, condition)
.foreach(step, { concurrency: 3 })
```

**Acceptance Criteria Mapping:**
- AC-10.1: Branch node: if/else based on condition (P1)
- AC-10.2: Parallel node: run multiple paths simultaneously (P1)
- AC-10.3: Loop node: repeat until condition (P2)
- AC-10.4: Wait node: pause for human approval (P2)

**Note:** Phase 1 can be linear workflows only. Add control flow in later phases.

---

### PR-7: Custom Code Nodes

**What it means:** Nodes where user writes custom JavaScript/TypeScript code.

**Technical Requirements:**
- User can add "Code" node with custom JS/TS
- User defines input schema for code node
- User defines output schema for code node
- Code editor with syntax highlighting

**Acceptance Criteria Mapping:**
- AC-11.1: User can add Code node with custom JS/TS
- AC-11.2: User defines input schema for code node
- AC-11.3: User defines output schema for code node
- AC-11.4: Code editor with syntax highlighting

**Mastra Primitive Mapping:**
```typescript
const customStep = createStep({
  id: "custom-step",
  inputSchema: z.object({ ... }),  // User-defined
  outputSchema: z.object({ ... }), // User-defined
  execute: async ({ inputData }) => {
    // User-provided code
    return { ... };
  },
});
```

---

### PR-8: Runtime Inputs (Agent-Provided Values)

**What it means:** Values that agent provides when calling a workflow at execution time. Different from Configs (set once at assignment).

**Key Distinction:**
| Concept | When Set | Who Sets | Persisted? | Example |
|---------|----------|----------|------------|---------|
| **Configs** | At workflow assignment | User | Yes | `targetRepo = "agipo/frontend"` |
| **Runtime Inputs** | Each execution | Agent/Caller | No | `jobUrl = "https://..."`, `prNumber = 123` |

**Technical Requirements:**
- Author can define runtime inputs (name, type, required, description)
- Runtime inputs have schema (like tool parameters)
- Agent passes runtime input values when calling workflow
- Node parameters can reference runtime inputs: `{{inputs.jobUrl}}`
- Runtime inputs validated before execution

**Acceptance Criteria Mapping:**
- AC-6.1: Author can define runtime inputs (name, type, required, description)
- AC-6.2: Runtime inputs have schema (type validation)
- AC-6.3: Agent passes runtime input values when calling workflow
- AC-6.4: Node parameters can reference inputs via `{{inputs.x}}`
- AC-6.5: Runtime inputs validated before execution

**Data Model:**
```typescript
interface RuntimeInputConfig {
  key: string;           // "jobUrl"
  type: "string" | "number" | "boolean" | "array" | "object";
  label: string;         // "Job Listing URL"
  description?: string;
  required: boolean;
  default?: unknown;
  validation?: {
    format?: "email" | "url" | "date";
    min?: number;
    max?: number;
    pattern?: string;
  };
}
```

**Mastra Mapping:**
- Runtime inputs become workflow's `inputSchema`
- First step receives workflow input
- Subsequent steps receive previous step output (or mapped data)

---

### PR-9: Data Mapping (Output → Input Binding)

**What it means:** How the output of one node becomes the input of another. Core UX challenge of visual workflow editors.

**Technical Requirements:**
- When creating edge, show data mapping UI
- Display source node's output fields (available data)
- Display target node's input fields (required data)
- User can map: output field → input field
- Support nested field access: `user.contact.email` → `recipientEmail`
- Auto-map fields with matching names (optional, can disable)
- Show type mismatches as warnings

**Example Scenario:**
```
Node A ("Scrape Job Listing") outputs:
{
  "title": "Senior Engineer",
  "company": "Acme Inc",
  "requirements": ["TypeScript", "React"],
  "salary": { "min": 150000, "max": 200000 }
}

Node B ("Generate Resume") expects:
{
  "jobTitle": "string (required)",
  "companyName": "string (required)",
  "targetSkills": "string[] (required)",
  "salaryRange": "string (optional)"
}

Data Mapping:
  title → jobTitle
  company → companyName
  requirements → targetSkills
  (salary.min + "-" + salary.max) → salaryRange (via Code node for transforms)
```

**Acceptance Criteria Mapping:**
- AC-7.1: Data mapping UI shows source output fields
- AC-7.2: Data mapping UI shows target input fields
- AC-7.3: User can map output field → input field
- AC-7.4: Nested field access supported (e.g., `user.email`)
- AC-7.5: Auto-map matching field names (optional)
- AC-7.6: Type mismatches shown as warnings

**Mastra Primitive Mapping:**
```typescript
// Visual edge → Mastra .map() call
workflow
  .then(stepA)
  .map({
    jobTitle: { step: stepA, path: "title" },
    companyName: { step: stepA, path: "company" },
    targetSkills: { step: stepA, path: "requirements" },
  })
  .then(stepB)
```

**Data Model:**
```typescript
interface DataMapping {
  id: string;
  sourceStepId: string;        // Step providing data, or "__input__"
  targetStepId: string;        // Step receiving data, or "__output__"
  fieldMappings: FieldMapping[];
}

interface FieldMapping {
  sourcePath: string;          // "data.title" or "result.user.email"
  targetField: string;         // "jobTitle"
  sourceType?: string;
  targetType?: string;
  typeMatch?: "exact" | "coercible" | "incompatible";
}
```

**Special Mappings:**
- `sourceStepId === "__input__"` → References workflow's initial input
- `targetStepId === "__output__"` → Defines workflow's final output

---

### PR-10: Testing Suite

**What it means:** Tools for testing workflows before publishing or assigning to agents.

**Technical Requirements:**
- "Test" button runs workflow with user-provided inputs
- User can create and save named test cases
- Each test case stores: runtime input values + config values
- Test execution shows step-by-step results (which nodes ran, what they returned)
- Test execution shows errors clearly (which node failed, why)
- User can re-run saved test case with one click
- Test history: see past test runs and their results

**Test Case Structure:**
```typescript
interface TestCase {
  id: string;
  name: string;                    // "Basic flow", "Edge case: empty job listing"
  description?: string;
  
  // Pre-filled values for this test
  runtimeInputs: Record<string, unknown>;  // e.g., { jobUrl: "https://..." }
  configOverrides?: Record<string, unknown>; // Optional: override configs for testing
  
  // Metadata
  createdAt: string;
  lastRunAt?: string;
  lastRunStatus?: "passed" | "failed" | "error";
  lastRunDuration?: number;        // milliseconds
}
```

**Acceptance Criteria Mapping:**
- AC-8.1: Test button runs workflow with user-provided inputs
- AC-8.2: User can create and save named test cases
- AC-8.3: Test cases store runtime inputs + config values
- AC-8.4: Test execution shows step-by-step progress
- AC-8.5: Test execution shows errors clearly (which node, why)
- AC-8.6: Saved test case can be re-run with one click
- AC-8.7: Test history available (past runs + results)

**Mastra Execution:**
```typescript
// Use streaming for real-time updates
const run = await workflow.createRunAsync();
const { result, stream } = run.stream({ inputData: testInputs });

for await (const event of stream) {
  if (event.type === 'step-result') {
    // Update UI with step status
    onStepComplete(event.id, event.payload);
  }
}

const finalResult = await result;
// finalResult.steps = { [stepId]: { status, output, error } }
```

---

### PR-11: Error Handling

**What it means:** How the system handles and surfaces errors during workflow execution.

**Technical Requirements:**
- Catch and surface tool execution errors (API failures, timeouts)
- Show which node failed and the error message
- Distinguish error types: auth error vs API error vs validation error
- For auth errors: prompt user to reconnect the required integration
- Allow retry of failed node (without re-running entire workflow) (P2)
- Log errors for debugging (visible in test panel, agent activity)

**Error Categories:**
| Category | Example | User Action |
|----------|---------|-------------|
| **Validation Error** | Required runtime input missing | Fix input values, re-run |
| **Auth Error** | Gmail token expired | Reconnect Gmail, re-run |
| **API Error** | Rate limit exceeded | Wait and retry |
| **Data Error** | Node output doesn't match expected schema | Fix workflow design |
| **Timeout** | External API too slow | Increase timeout or handle gracefully |

**Acceptance Criteria Mapping:**
- AC-9.1: Tool execution errors caught and surfaced
- AC-9.2: Error display shows which node failed + message
- AC-9.3: Error types distinguished (auth/API/validation)
- AC-9.4: Auth errors prompt reconnection
- AC-9.5: Failed node retry possible (P2)
- AC-9.6: Errors logged for debugging

**Mastra Error Handling:**
```typescript
// Step-level retry config
const step = createStep({
  id: "risky-step",
  retries: 3,  // Retry up to 3 times on failure
  execute: async ({ inputData }) => { ... },
});

// Workflow-level retry config
const workflow = createWorkflow({
  id: "my-wf",
  retryConfig: {
    attempts: 3,
    delay: 1000,
  },
});

// Error result structure
result.steps = {
  [stepId]: {
    status: 'failed',
    error: string | Error,
    payload: any,        // Input that caused the error
    startedAt: number,
    endedAt: number,
  }
}
```

---

### PR-12: Table Integration (Records)

**What it means:** Workflows can read from and write to structured data tables (Records feature).

**Technical Requirements:**
- Workflow can declare table requirements (read/write/readwrite purpose)
- Table requirements specify required columns with types
- Multiple table requirements per workflow supported
- When assigning workflow to agent, user selects table for each requirement
- User can auto-create new table with required schema during assignment
- Table reference accessible to nodes via `{{configs.tableKey}}`
- Column mapping at assignment time (if workflow columns ≠ table columns)
- Dedicated "Query Table" node type
- Dedicated "Write to Table" node type

**Table Requirement Structure:**
```typescript
interface TableRequirement {
  key: string;                    // Internal reference: "output_table"
  purpose: "read" | "write" | "readwrite";
  description: string;            // "Table to store scraped job listings"
  
  requiredColumns: Array<{
    key: string;                  // How workflow references it: "job_title"
    suggestedName: string;        // Suggested column name: "Job Title"
    type: "text" | "number" | "date" | "boolean" | "select";
    required: boolean;
  }>;
  
  canAutoCreate: boolean;         // Show "Create new table" option
  autoCreateName?: string;        // Suggested name for new table
}
```

**Acceptance Criteria Mapping:**
- AC-15.1 through AC-15.12 (12 criteria covering table requirements, assignment, nodes, column mapping)

**Note:** Table integration is Phase 6 (out of scope for MVP). Focus on core workflow composition first.

---

## Part 2: Technical Architecture Deep Dive

### 2.1 Mastra Primitive Mapping (Non-Negotiable)

Every visual element MUST translate to Mastra code. This mapping is **not negotiable**:

| Visual Editor Concept | Mastra Primitive | Generated Code Pattern |
|----------------------|------------------|----------------------|
| A node on canvas/list | `Step` | `createStep({ id, inputSchema, outputSchema, execute })` |
| **A line between nodes** | **`.map()`** | `{ field: { step: sourceStep, path: "sourcePath" } }` |
| The workflow itself | `Workflow` | `createWorkflow({ id, inputSchema, outputSchema })` |
| Sequential connection | `.then()` | `.then(stepA).then(stepB)` |
| Fork to parallel paths | `.parallel()` | `.parallel([stepA, stepB])` |
| If/else branch | `.branch()` | `.branch([[condition, step], ...])` |
| Finalize | `.commit()` | Always required at end |

**Critical Insight:** `.map()` is the "line" concept. It's not just a connection—it's a transformation specification.

---

### 2.2 Data Model (workflow.json Schema)

**Single Source of Truth:** `workflow.json` stores editor state. Both list view and canvas view read/write the same file.

**Key Design Decisions:**
- Dual position tracking: `position` (canvas) + `listIndex` (list view)
- Explicit mappings array: Separate from steps, easier to edit
- Control flow at top level: Matches Mastra's workflow structure
- Cached schemas: Stored in workflow.json to avoid API calls
- Step type field: `"composio"` / `"custom"` / `"control"` / `"query_table"` / `"write_table"`

**File Structure:**
```
_tables/workflows-e/[workflowId]/
  ├── workflow.json    # Editor state (nodes, edges, mappings, configs)
  └── workflow.ts      # Generated Mastra code (executable)
```

**Transpilation:** workflow.json → workflow.ts is **deterministic**. Same JSON always produces same TypeScript.

---

### 2.3 Composio Integration

**Key Findings from Research:**
- ✅ Composio DOES expose `outputParameters` (verified Dec 6, 2025)
- ✅ `@composio/mastra` package incompatible with `@mastra/core@0.24.6`
- ✅ Manual wrapping required (use existing `composio-tools.ts` patterns)

**Tool Wrapping Pattern:**
```typescript
function createComposioStep(
  toolId: string,
  toolkitSlug: string,
  connectionId: string
) {
  const tool = await client.tools.retrieve(toolId);
  
  return createStep({
    id: `composio-${toolId.toLowerCase()}`,
    inputSchema: jsonSchemaToZod(tool.input_parameters),
    outputSchema: tool.output_parameters 
      ? jsonSchemaToZod(tool.output_parameters)
      : z.record(z.string(), z.any()),
    execute: async ({ inputData, resourceId }) => {
      const result = await client.tools.execute(toolId, {
        arguments: inputData,
        connected_account_id: connectionId,
        user_id: resourceId,
      });
      if (!result.successful) {
        throw new Error(result.error || "Tool execution failed");
      }
      return result.data;
    },
  });
}
```

**Connection ID Resolution:**
- Stored in `WorkflowDefinition.connections` as `{ [toolkitSlug]: connectionId | null }`
- `null` means inherit from agent at runtime
- Generated code uses placeholder: `{{connectionId:firecrawl}}`
- Resolved at execution time

---

### 2.4 Code Generation Strategy

**Decision: Hybrid Approach**
- **Runtime construction** for testing (fast iteration, instant preview)
- **Code generation** for production (type-safe, versionable, debuggable)

**Generated workflow.ts Structure:**
```typescript
// _tables/workflows-e/[workflowId]/workflow.ts
// Auto-generated from workflow.json - DO NOT EDIT DIRECTLY

import { createWorkflow, createStep } from "@mastra/core";
import { z } from "zod";
import { getComposioClient } from "@/app/api/connections/services/composio";

// Input/Output Schemas
const inputSchema = z.object({
  jobUrl: z.string().url(),
  baseResume: z.string(),
});

const outputSchema = z.object({
  tailoredResume: z.string(),
});

// Step Definitions
const scrapeJobStep = createStep({
  id: "scrape-job",
  description: "Extract job details from the URL",
  inputSchema: z.object({ url: z.string().url() }),
  outputSchema: z.object({
    data: z.record(z.string(), z.any()),
    error: z.string().optional(),
    successful: z.boolean(),
  }),
  execute: async ({ inputData, resourceId }) => {
    const client = getComposioClient();
    const result = await client.tools.execute("FIRECRAWL_SCRAPE", {
      arguments: inputData,
      connected_account_id: "{{connectionId:firecrawl}}",
      user_id: resourceId,
    });
    if (!result.successful) {
      throw new Error(result.error || "Tool execution failed");
    }
    return result.data;
  },
});

// Workflow Composition
export const jobApplicationHelperWorkflow = createWorkflow({
  id: "job-application-helper",
  description: "Scrapes job listings and generates tailored resumes",
  inputSchema,
  outputSchema,
})
  .then(scrapeJobStep)
  .map({
    jobTitle: { step: scrapeJobStep, path: "data.title" },
    companyName: { step: scrapeJobStep, path: "data.company" },
    requirements: { step: scrapeJobStep, path: "data.requirements" },
    baseResume: { initData: jobApplicationHelperWorkflow, path: "baseResume" },
  })
  .then(generateResumeStep)
  .commit();
```

**Transpilation Rules:**
1. JSON Schema → Zod Schema (deterministic conversion)
2. Mappings → `.map()` call (field-by-field mapping)
3. Control flow → chained methods (`.then()`, `.parallel()`, `.branch()`)
4. Connection placeholders → resolved at execution time

---

## Part 3: Visual Editor Views

### 3.1 List View (Primary)

**Based on:** Flight A Variation 3 (Timeline with progressive disclosure)

**Characteristics:**
- Sequential steps in vertical timeline
- Progressive disclosure (expand to see details)
- Data flow indicators between steps
- Mapping badges showing field connections
- More approachable for non-technical users

**Data Flow Visualization:**
- Inline badges: "← Step 1.title" next to each input field
- Or hover/expand: Expand step to see mapping details
- Or separate panel: Click edge indicator to see mapping in sidebar

**Implementation:**
- Sort steps by `listIndex`
- Show step name, type icon, I/O summary
- Data source indicators from mappings where `targetStepId === step.id`

---

### 3.2 Canvas View (Secondary)

**Based on:** ReactFlow (proven in existing tool editor)

**Characteristics:**
- Nodes positioned by `position: { x, y }`
- Edges derived from mappings
- Drag-drop node repositioning
- Visual data flow as lines
- Power-user friendly

**Implementation:**
- Custom node components (ToolNode, CustomCodeNode, ControlNode)
- Custom edge components (DataEdge with mapping indicators)
- Zoom/pan controls
- Node selection highlights

**State Sync:**
- Both views read/write same `workflow.json`
- Reorder in list → updates `listIndex` + `controlFlow.order`
- Move node in canvas → updates `position`
- Changes reflected immediately in both views

---

### 3.3 Abstraction Levels (Flight C Feature)

**From Flight C Variation B mockup:**
- **Flow** view: Visual editor (list/canvas)
- **Spec** view: Standard Operating Procedure document (human-readable)
- **Code** view: Generated TypeScript code preview

**Implementation Notes:**
- Flow: Default editor view
- Spec: Generate from workflow definition (markdown/HTML)
- Code: Show generated `workflow.ts` (read-only preview)

---

## Part 4: Variation Pattern Understanding

### 4.1 Existing Variations

**Variation A (workflows/):**
- Original implementation
- List view emphasis (Flight A V3)
- Basic structure, stores, components started

**Variation B (workflows-b/):**
- Minimal structure (store slices only)
- Status unclear

**Variation C (workflows-c/):**
- "Blueprint" power-user aesthetic
- Dark theme, command palette (Cmd+K)
- Code preview, data inspector
- Keyboard-driven

**Variation D (workflows-d/):**
- Similar structure to A
- Status unclear

### 4.2 Variation E (My Implementation)

**Based on:** Flight C Variation B mockup (interactive HTML prototype)

**Key Differentiators:**
1. **Abstraction Level Toggle:** Flow / Spec / Code views
2. **Collapsible AI Chat Panel:** Left sidebar with collapse/expand
3. **Tabbed Settings Panel:** Tools, Inputs, Config, Connect, Test
4. **Test Execution Modal:** Step-by-step progress with real-time updates
5. **Data Mapping Modal:** Visual field mapping UI
6. **Modern Dark Theme:** `#0a0a14` background, indigo accents
7. **View Toggle:** List ↔ Canvas with state sync

**Visual Identity:**
- Background: `#0a0a14` (very dark)
- Accent: Indigo (`#6366f1`)
- Cards: `#12121f` with borders
- Dot pattern canvas background
- Space Grotesk font (UI), JetBrains Mono (code)

**Layout Structure:**
```
┌─────────────────────────────────────────────────────────────┐
│  Top Bar: Name, Abstraction Toggle, View Toggle, Test/Save │
├──────────┬──────────────────────────────────────┬──────────┤
│          │                                      │           │
│   AI     │         Workflow Area                │ Settings │
│  Chat    │    (List or Canvas View)             │  (Tabs)  │
│ (Left)   │                                      │ (Right)  │
│          │                                      │           │
└──────────┴──────────────────────────────────────┴──────────┘
```

---

## Part 5: Implementation Phases (Variation E)

### Phase 1: Foundation & Navigation
- [ ] Create `app/(pages)/workflows-e/` folder
- [ ] Create `app/api/workflows-e/` folder
- [ ] Create `_tables/workflows-e/` folder
- [ ] Add "Workflows E" to TopNav
- [ ] Create list page (`page.tsx`)
- [ ] Create basic API routes (create, list, get, update)
- [ ] Create storage service

**Acceptance:** Can navigate to `/workflows-e`, see list page, create new workflow

---

### Phase 2: Editor Shell & Store
- [ ] Create editor page (`editor/page.tsx`)
- [ ] Create 3-panel layout (AI chat left, workflow center, settings right)
- [ ] Create Zustand store with slices:
  - `workflowSlice` (workflow identity)
  - `stepsSlice` (steps management)
  - `mappingsSlice` (data mappings)
  - `inputsSlice` (runtime inputs)
  - `configsSlice` (workflow configs)
  - `connectionsSlice` (required connections)
  - `uiSlice` (view mode, abstraction level, AI panel state)
  - `testingSlice` (test execution state)
- [ ] Create EditorHeader component
- [ ] Create EditorSidebar (AI chat, collapsible)
- [ ] Create EditorMain (workflow area)
- [ ] Create EditorInspector (tabbed settings panel)

**Acceptance:** Editor loads with 3-panel layout, store initializes

---

### Phase 3: List View Implementation
- [ ] Create StepTimeline component
- [ ] Create StepCard (collapsed state)
- [ ] Create StepCardExpanded (expanded details)
- [ ] Create DataFlowIndicator (arrow between steps)
- [ ] Create AddStepButton
- [ ] Implement step selection
- [ ] Implement step reordering

**Acceptance:** Steps render in timeline, can expand/collapse, can reorder

---

### Phase 4: Tool Palette Integration
- [ ] Create ToolPalette component (in settings panel)
- [ ] Create ToolPaletteGroup (toolkit grouping)
- [ ] Create ToolPaletteItem
- [ ] Create `useComposioTools` hook
- [ ] Fetch tools from Composio API
- [ ] Display tools grouped by toolkit
- [ ] Add search/filter
- [ ] Implement "add step" action

**Acceptance:** Tools visible in palette, grouped by toolkit, searchable, click adds step

---

### Phase 5: Data Mapping UI
- [ ] Create DataMappingModal component
- [ ] Show source output fields
- [ ] Show target input fields
- [ ] Implement field mapping selection
- [ ] Support nested paths (`data.user.email`)
- [ ] Auto-map matching field names
- [ ] Type validation indicators
- [ ] Save mappings to store

**Acceptance:** Can create edge, mapping modal opens, can map fields, type validation works

---

### Phase 6: Runtime Inputs & Configs
- [ ] Create InputsPanel component (in settings tabs)
- [ ] Create ConfigPanel component (in settings tabs)
- [ ] Implement CRUD for runtime inputs
- [ ] Implement CRUD for configs
- [ ] Make inputs/configs available in mapping dropdowns
- [ ] Reference syntax: `{{inputs.x}}`, `{{configs.x}}`

**Acceptance:** Can add/edit inputs and configs, can reference in mappings

---

### Phase 7: Connections Panel
- [ ] Create ConnectionsPanel component (in settings tabs)
- [ ] Auto-detect required connections from steps
- [ ] Show connected/not-connected status
- [ ] Link to connections page for missing

**Acceptance:** Required connections auto-detected, status shown, missing connections highlighted

---

### Phase 8: Test Execution
- [ ] Create TestPanel component (in settings tabs)
- [ ] Create test execution form (runtime inputs)
- [ ] Implement test execution API route
- [ ] Implement executor service (runtime workflow construction)
- [ ] Stream execution events (step-by-step progress)
- [ ] Display step status (running, success, failed)
- [ ] Display step outputs
- [ ] Display errors clearly
- [ ] Create TestExecutionModal (full-screen progress)

**Acceptance:** Can run test, see step-by-step progress, see errors, test completes

---

### Phase 9: Code Generation
- [ ] Create generator service (`generator.ts`)
- [ ] JSON Schema → Zod conversion
- [ ] Mappings → `.map()` call generation
- [ ] Control flow → chained methods
- [ ] Generate `workflow.ts` on save
- [ ] Validate generated code (TypeScript compilation check)

**Acceptance:** Save generates `workflow.ts`, code is valid TypeScript, uses Mastra primitives

---

### Phase 10: Canvas View
- [ ] Install ReactFlow
- [ ] Create WorkflowCanvas component
- [ ] Create StepNode custom node
- [ ] Create DataEdge custom edge
- [ ] Implement node positioning
- [ ] Implement edge rendering from mappings
- [ ] Add view toggle (List ↔ Canvas)
- [ ] Sync state between views

**Acceptance:** Canvas view renders, nodes positioned, edges connect, state syncs

---

### Phase 11: Abstraction Levels
- [ ] Implement Flow view (default editor)
- [ ] Implement Spec view (generate SOP document)
- [ ] Implement Code view (show generated TypeScript)
- [ ] Add abstraction level toggle in header

**Acceptance:** Can toggle between Flow/Spec/Code views

---

### Phase 12: Polish & Integration
- [ ] Error boundaries
- [ ] Loading states
- [ ] Empty states
- [ ] Keyboard shortcuts
- [ ] Final styling pass
- [ ] Integration with agent assignment (future)

**Acceptance:** All acceptance criteria pass, no console errors, graceful error handling

---

## Part 6: Acceptance Criteria Checklist (81 Total)

### Discovery & Tool Palette (7 criteria)
- [ ] AC-1.1: Palette displays Composio tools from connected integrations
- [ ] AC-1.2: Palette displays NO_AUTH tools
- [ ] AC-1.3: Each tool shows input schema
- [ ] AC-1.4: Each tool shows output schema
- [ ] AC-1.5: Tools grouped by toolkit
- [ ] AC-1.6: Tools searchable by name
- [ ] AC-1.7: Drag/click tool creates node

### IPO Model & Nodes (6 criteria)
- [ ] AC-2.1: Each node displays input schema
- [ ] AC-2.2: Each node displays output schema
- [ ] AC-2.3: Nodes connect via edges
- [ ] AC-2.4: Clicking edge opens data mapping UI
- [ ] AC-2.5: Terminal nodes display correctly
- [ ] AC-2.6: Node inspector shows full I/O details

### Connection Validation (4 criteria)
- [ ] AC-3.1: Type validation runs when creating edge
- [ ] AC-3.2: Invalid connections show visual indicator
- [ ] AC-3.3: Coercible types show warning but allow
- [ ] AC-3.4: Incompatible types block connection

### Connection Requirements (4 criteria)
- [ ] AC-4.1: Adding tool node auto-detects required connection
- [ ] AC-4.2: Required connections displayed in panel
- [ ] AC-4.3: Validate when assigning to agent
- [ ] AC-4.4: Block execution if connections missing

### Configs (5 criteria)
- [ ] AC-5.1: Author can define configs
- [ ] AC-5.2: Node parameters can reference configs
- [ ] AC-5.3: Config values requested at assignment
- [ ] AC-5.4: Config values stored per binding
- [ ] AC-5.5: Supported config types work

### Runtime Inputs (5 criteria)
- [ ] AC-6.1: Author can define runtime inputs
- [ ] AC-6.2: Runtime inputs have schema
- [ ] AC-6.3: Agent passes runtime input values
- [ ] AC-6.4: Node parameters can reference inputs
- [ ] AC-6.5: Runtime inputs validated before execution

### Data Mapping (6 criteria)
- [ ] AC-7.1: Data mapping UI shows source fields
- [ ] AC-7.2: Data mapping UI shows target fields
- [ ] AC-7.3: User can map output field → input field
- [ ] AC-7.4: Nested field access supported
- [ ] AC-7.5: Auto-map matching field names
- [ ] AC-7.6: Type mismatches shown as warnings

### Testing Suite (7 criteria)
- [ ] AC-8.1: Test button runs workflow with inputs
- [ ] AC-8.2: User can create and save test cases
- [ ] AC-8.3: Test cases store inputs + configs
- [ ] AC-8.4: Test execution shows step-by-step progress
- [ ] AC-8.5: Test execution shows errors clearly
- [ ] AC-8.6: Saved test case can be re-run
- [ ] AC-8.7: Test history available

### Error Handling (6 criteria)
- [ ] AC-9.1: Tool execution errors caught and surfaced
- [ ] AC-9.2: Error display shows which node failed
- [ ] AC-9.3: Error types distinguished
- [ ] AC-9.4: Auth errors prompt reconnection
- [ ] AC-9.5: Failed node retry possible (P2)
- [ ] AC-9.6: Errors logged for debugging

### Control Flow (4 criteria - P1/P2)
- [ ] AC-10.1: Branch node: if/else based on condition (P1)
- [ ] AC-10.2: Parallel node: run multiple paths (P1)
- [ ] AC-10.3: Loop node: repeat until condition (P2)
- [ ] AC-10.4: Wait node: pause for approval (P2)

### Custom Code Nodes (4 criteria - P1)
- [ ] AC-11.1: User can add Code node
- [ ] AC-11.2: User defines input schema
- [ ] AC-11.3: User defines output schema
- [ ] AC-11.4: Code editor with syntax highlighting

### Visual Editor Views (4 criteria)
- [ ] AC-12.1: Canvas view displays workflow as graph
- [ ] AC-12.2: List view displays workflow as sequential steps
- [ ] AC-12.3: Both views read/write same state
- [ ] AC-12.4: View toggle persists preference

### Persistence & Storage (3 criteria)
- [ ] AC-13.1: Workflow saved to `_tables/workflows-e/[id]/workflow.json`
- [ ] AC-13.2: Generated code saved to `workflow.ts`
- [ ] AC-13.3: Auto-save during editing

### Agent Integration (4 criteria - Future)
- [ ] AC-14.1: Workflow can be assigned to agent
- [ ] AC-14.2: Agent can call workflow with runtime inputs
- [ ] AC-14.3: Workflow results returned to agent
- [ ] AC-14.4: No WebContainers required

### Table Integration (12 criteria - Phase 6)
- [ ] AC-15.1 through AC-15.12 (table requirements, assignment, nodes, mapping)

---

## Part 7: Key Technical Decisions for Variation E

### 7.1 File Naming
- **Storage:** `workflow.json` (editor state) + `workflow.ts` (generated code)
- **Rationale:** Consistent with existing patterns, clear distinction

### 7.2 State Management
- **Pattern:** Zustand with slice composition (like existing variations)
- **Slices:** workflow, steps, mappings, inputs, configs, connections, tables, ui, testing
- **Rationale:** Consistent with existing patterns, proven architecture

### 7.3 Composio Tool Fetching
- **Pattern:** Use existing `app/api/tools/services/composio-tools.ts`
- **Caching:** Store tool schemas in workflow.json to avoid repeated API calls
- **Rationale:** Reuse existing service, reduce API calls

### 7.4 Code Generation
- **Strategy:** Hybrid (runtime for testing, code-gen for production)
- **Format:** Deterministic JSON → TypeScript transpilation
- **Rationale:** Fast iteration + reliable production

### 7.5 Data Mapping
- **MVP:** Direct field mapping only (no transforms)
- **Transforms:** Use Code nodes for complex transformations
- **Auto-map:** Yes, with opt-out
- **Rationale:** Keep MVP simple, Code nodes handle complex cases

### 7.6 Connection ID Resolution
- **Pattern:** Placeholders in generated code: `{{connectionId:firecrawl}}`
- **Resolution:** At execution time, from agent's connection bindings
- **Rationale:** Workflow is blueprint, connections bound at assignment

---

## Part 8: What Makes Variation E Unique

### 8.1 Abstraction Level Toggle
**Unique Feature:** Flow / Spec / Code views
- **Flow:** Visual editor (list/canvas)
- **Spec:** Human-readable SOP document
- **Code:** Generated TypeScript preview

**Implementation:**
- Generate Spec view from workflow definition (markdown/HTML)
- Show Code view as read-only preview of generated `workflow.ts`
- Toggle in header (Flow/Spec/Code buttons)

### 8.2 Collapsible AI Chat Panel
**Unique Feature:** Left sidebar with collapse/expand
- Default: Expanded (320px width)
- Collapsed: Icon button only (64px width)
- Smooth transition animation
- Green indicator dot when online

**Implementation:**
- Store `aiPanelExpanded` in `uiSlice`
- CSS transition for width change
- Collapse button in chat header
- Expand button in collapsed state

### 8.3 Tabbed Settings Panel
**Unique Feature:** Right panel with tabs (Tools, Inputs, Config, Connect, Test)
- **Tools:** Tool palette (grouped by toolkit, searchable)
- **Inputs:** Runtime inputs configuration
- **Config:** Workflow configs
- **Connect:** Required connections display
- **Test:** Test execution UI

**Implementation:**
- Tab state in `uiSlice`
- Each tab is separate component
- Active tab highlighted

### 8.4 Test Execution Modal
**Unique Feature:** Full-screen modal with step-by-step progress
- Real-time step status updates
- Progress bar
- Step cards with status indicators
- Error display
- Stop button

**Implementation:**
- Use Mastra's `run.stream()` for real-time events
- Modal component with step cards
- Update UI as events stream in

### 8.5 Data Mapping Modal
**Unique Feature:** Visual field mapping UI
- Side-by-side: Source outputs | Target inputs
- Drag or select mappings
- Type validation indicators
- Auto-map button

**Implementation:**
- Modal component
- Two-column layout
- Field selection UI
- Type validation logic

---

## Part 9: Implementation Readiness Checklist

### Research Complete ✅
- [x] All RQ questions answered (12/12)
- [x] All OQ decisions made
- [x] Mastra primitives understood
- [x] Composio integration patterns understood
- [x] Data model designed

### Requirements Understood ✅
- [x] All 81 acceptance criteria reviewed
- [x] All 12 product requirements understood
- [x] User flows mapped
- [x] Technical architecture designed

### Variation Pattern Understood ✅
- [x] Existing variations analyzed
- [x] Flight C Variation B mockup studied
- [x] Unique features identified
- [x] Implementation phases planned

### Ready to Implement ✅
- [x] Folder structure planned
- [x] Store architecture designed
- [x] Component structure planned
- [x] API routes planned
- [x] Code generation strategy defined

---

## Part 10: Next Steps

1. **Get Approval:** Review this understanding document
2. **Start Phase 1:** Foundation & Navigation
3. **Iterate:** Build phase by phase, test acceptance criteria
4. **Polish:** Final styling, error handling, edge cases

---

## References

- **Product Spec:** `15-workflow-editor.md`
- **Research:** `15.1-workflow-research.md`, `15.2-workflow-research.md`
- **Schema Design:** `15.3a-workflow-json-schema.md`
- **Implementation Plans:** `15.3-workflow-implementation.md`, `15.4-workflow-implementation.md`, `15.5-workflows-c-implementation.md`
- **Mastra Primitives:** `_docs/Engineering/Integrations/API Docs/Mastra/Workflow-Primitives.md`
- **UXD Mockup:** `_docs/UXD/Pages/workflow/Flight C/variation-b/index.html`
- **Existing Variations:** `app/(pages)/workflows/`, `app/(pages)/workflows-c/`, etc.

