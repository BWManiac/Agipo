# Task 15.2: Workflow Editor Research (Parallel Track)

**Status:** ✅ Complete  
**Date:** December 6, 2025  
**Parent Task:** [15-workflow-editor.md](./15-workflow-editor.md)  
**Parallel To:** [15.1-workflow-research.md](./15.1-workflow-research.md)

---

## Research Philosophy

This research follows a **grounded methodology**:

1. **External Reality (Immutable)**: Mastra's API is what it is. Composio either exposes output schemas or it doesn't. We discover truth.
2. **Internal Decisions (Mutable)**: Given external truth, we make design choices. These must be grounded in reality.
3. **Prevent Failure Mode**: Never design for an API that doesn't exist.

**Each research question answers:**
- **Discover Truth**: What does the API actually provide?
- **Map to Requirement**: Does this satisfy PR-X.X? How?
- **Identify Decisions**: Where do we have choices? What are tradeoffs?
- **Make Actionable**: "Call X with Y to get Z" - specific, not conceptual

---

## Quick Reference: Questions → Requirements

| Question | Requirement | Status |
|----------|-------------|--------|
| [RQ-1: Workflow Input Schema](#rq-1-how-do-we-define-workflow-input-schema) | PR-8 Runtime Inputs | ✅ |
| [RQ-2: Step Definition](#rq-2-how-do-we-define-a-step) | PR-2 IPO Model | ✅ |
| [RQ-3: Data Between Steps](#rq-3-how-does-data-pass-between-steps) | PR-9 Data Mapping | ✅ |
| [RQ-4: Sequential Execution](#rq-4-how-do-we-chain-steps-sequentially) | PR-2 IPO Model | ✅ |
| [RQ-5: Parallel Execution](#rq-5-how-do-we-run-steps-in-parallel) | PR-6 Control Flow | ✅ |
| [RQ-6: Conditional Branching](#rq-6-how-do-we-branch-conditionally) | PR-6 Control Flow | ✅ |
| [RQ-7: Error Handling](#rq-7-how-are-errors-handled) | PR-11 Error Handling | ✅ |
| [RQ-8: Workflow Execution](#rq-8-how-do-we-execute-a-workflow) | PR-10 Testing | ✅ |
| [RQ-9: Code-Gen vs Runtime](#rq-9-does-mastra-require-code-files-or-accept-runtime-definitions) | Architecture | ✅ |
| [RQ-10: Composio Output Schemas](#rq-10-does-composio-expose-output-schemas) | PR-1 Node Discovery | ✅ |
| [RQ-11: Composio Toolkit Extraction](#rq-11-how-do-we-get-toolkit-from-tool) | PR-4 Connection Req | ✅ |
| [RQ-12: Composio + Mastra Integration](#rq-12-how-do-we-wrap-composio-tools-as-mastra-steps) | PR-2, PR-4 | ✅ |

---

## Part 1: Mastra Workflow Research

### RQ-1: How do we define workflow input schema?

**Maps to Requirement:** PR-8 (Runtime Inputs) - Workflows need to accept inputs from agents at execution time.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** When creating a workflow, how do we declare what inputs it accepts? What's the schema format?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/types.d.ts
type WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps> = {
  mastra?: Mastra;
  id: TWorkflowId;
  description?: string;
  inputSchema: TInput;        // ← Zod schema defining workflow inputs
  outputSchema: TOutput;      // ← Zod schema defining workflow outputs
  stateSchema?: TState;       // ← Optional shared state schema
  executionEngine?: ExecutionEngine;
  steps?: TSteps;
  retryConfig?: { attempts?: number; delay?: number };
  options?: WorkflowOptions;
};

// Usage:
import { createWorkflow } from "@mastra/core";
import { z } from "zod";

const workflow = createWorkflow({
  id: "my-workflow",
  inputSchema: z.object({
    recipientEmail: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  outputSchema: z.object({
    success: z.boolean(),
    messageId: z.string().optional(),
  }),
});
```

**Satisfies PR-8?** ✅ YES - Mastra uses Zod schemas for both input and output. We can generate these from our visual editor.

**Decisions We Control:**
- How to serialize Zod schemas in our workflow JSON format
- Whether to use JSON Schema internally and convert to Zod at generation time

**Actionable Primitive:**
```typescript
// Our workflow definition → Mastra code generation
const agigpoWorkflowDef = {
  inputs: [
    { name: "recipientEmail", type: "string", format: "email", required: true },
    { name: "subject", type: "string", required: true },
  ],
};

// Generates:
const inputSchema = z.object({
  recipientEmail: z.string().email(),
  subject: z.string(),
});
```

**Source:** `@mastra/core/dist/workflows/types.d.ts` lines 329-343

---

### RQ-2: How do we define a step?

**Maps to Requirement:** PR-2 (IPO Model) - Each node in our editor becomes a step with input/output.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** What is the `createStep()` signature? How do we define what a step accepts and returns?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts
type StepParams<TStepId, TState, TStepInput, TStepOutput, TResumeSchema, TSuspendSchema> = {
  id: TStepId;                    // Unique step identifier
  description?: string;           // Human-readable description
  inputSchema: TStepInput;        // Zod schema for step input
  outputSchema: TStepOutput;      // Zod schema for step output
  resumeSchema?: TResumeSchema;   // For human-in-the-loop
  suspendSchema?: TSuspendSchema; // For suspension points
  stateSchema?: TState;           // Shared state access
  retries?: number;               // Retry count
  scorers?: DynamicArgument<MastraScorers>; // For evaluation
  execute: ExecuteFunction<...>;  // The actual execution logic
};

// Step interface:
interface Step<TStepId, TState, TSchemaIn, TSchemaOut, TResumeSchema, TSuspendSchema, TEngineType> {
  id: TStepId;
  description?: string;
  inputSchema: TSchemaIn;
  outputSchema: TSchemaOut;
  resumeSchema?: TResumeSchema;
  suspendSchema?: TSuspendSchema;
  stateSchema?: TState;
  execute: ExecuteFunction<...>;
  retries?: number;
}

// Execute function receives:
type ExecuteFunctionParams<TState, TStepInput, TResumeSchema, TSuspendSchema, EngineType> = {
  runId: string;
  resourceId?: string;
  workflowId: string;
  mastra: Mastra;
  runtimeContext: RuntimeContext;
  inputData: TStepInput;           // ← The input data for this step
  state: TState;                   // ← Access to shared state
  setState(state: TState): void;   // ← Modify shared state
  resumeData?: TResumeSchema;
  runCount: number;
  tracingContext: TracingContext;
  getInitData<T>(): T;             // ← Get workflow initial input
  getStepResult<T>(stepId: T): T;  // ← Get previous step output
  suspend(payload, options): Promise<any>;  // ← Human-in-the-loop
  bail(result): any;               // ← Early exit
  abort(): any;                    // ← Cancel execution
  abortSignal: AbortSignal;
  writer: ToolStream<ChunkType>;   // ← Streaming support
};

// Usage:
const sendEmailStep = createStep({
  id: "send-email",
  description: "Sends an email via Gmail",
  inputSchema: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  outputSchema: z.object({
    messageId: z.string(),
    success: z.boolean(),
  }),
  execute: async ({ inputData, mastra }) => {
    // Execute Composio tool here
    const result = await composioExecute(inputData);
    return { messageId: result.id, success: true };
  },
});
```

**Satisfies PR-2?** ✅ YES - Perfect IPO model: `inputSchema` (I), `execute` (P), `outputSchema` (O).

**Decisions We Control:**
- How to map visual nodes to step definitions
- Whether steps are generated as code or created dynamically

**Actionable Primitive:**
```typescript
// Visual node → Mastra step
function generateStepCode(node: WorkflowNode): string {
  return `
const ${node.id}Step = createStep({
  id: "${node.id}",
  description: "${node.data.description || ''}",
  inputSchema: ${generateZodSchema(node.data.inputSchema)},
  outputSchema: ${generateZodSchema(node.data.outputSchema)},
  execute: async ({ inputData }) => {
    return await composioExecute("${node.data.toolId}", inputData);
  },
});`;
}
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 36-69, `step.d.ts` lines 15-62

---

### RQ-3: How does data pass between steps?

**Maps to Requirement:** PR-9 (Data Mapping) - When Node A outputs `{title, company}` and Node B needs `{jobTitle}`, how does the mapping work?

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** Does Mastra use a shared context object? Return values? How do we access previous step's output?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts

// 1. Via execute function params - getStepResult()
execute: async ({ inputData, getStepResult }) => {
  const previousOutput = getStepResult(previousStep);  // ← Get specific step output
  const initialInput = getInitData();                  // ← Get workflow input
  // ...
}

// 2. Via .map() method - declarative mapping
workflow
  .then(stepA)
  .map({
    // Option A: Reference step output path
    jobTitle: { step: stepA, path: "title" },
    
    // Option B: Literal value with schema
    defaultCompany: { value: "Acme Inc", schema: z.string() },
    
    // Option C: Reference initial workflow input
    requestId: { initData: workflow, path: "requestId" },
    
    // Option D: Runtime context
    userId: { runtimeContextPath: "userId", schema: z.string() },
    
    // Option E: Dynamic mapping function
    fullName: {
      fn: async ({ inputData }) => `${inputData.firstName} ${inputData.lastName}`,
      schema: z.string(),
    },
  })
  .then(stepB);

// 3. mapVariable helper for type safety
import { mapVariable } from "@mastra/core";
workflow
  .then(stepA)
  .map({
    jobTitle: mapVariable({ step: stepA, path: "title" }),
  })
  .then(stepB);

// Full .map() signature:
map(mappingConfig: {
  [key: string]: 
    | { step: Step; path: string }                    // Step output ref
    | { step: Step[]; path: string }                  // Multiple steps (first available)
    | { value: any; schema: z.ZodType }               // Literal value
    | { initData: Workflow; path: string }            // Initial input ref
    | { runtimeContextPath: string; schema: z.ZodType } // Runtime context
    | DynamicMapping<TPrevSchema, TSchemaOut>         // Function
} | ExecuteFunction<...>): Workflow;
```

**Satisfies PR-9?** ✅ YES - `.map()` provides declarative field mapping. We can visualize this as edge configurations.

**Decisions We Control:**
- UI for configuring mappings (dropdown, drag-drop, expression builder)
- Whether to support dynamic function mappings in MVP
- How to visualize the mapping in the edge inspector

**Actionable Primitive:**
```typescript
// Visual edge mapping → Mastra .map() call
function generateMappingCode(edge: WorkflowEdge): string {
  const mappings = edge.data.mappings.map(m => {
    if (m.type === 'direct') {
      return `${m.target}: { step: ${m.sourceStep}Step, path: "${m.sourcePath}" }`;
    } else if (m.type === 'literal') {
      return `${m.target}: { value: ${JSON.stringify(m.value)}, schema: z.${m.schema}() }`;
    }
  });
  
  return `.map({ ${mappings.join(', ')} })`;
}
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 122-138

---

### RQ-4: How do we chain steps sequentially?

**Maps to Requirement:** PR-2 (IPO Model) - Most workflows are linear: Step A → Step B → Step C.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** What is the `.then()` or equivalent method signature?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts

// .then() chains steps sequentially
then<TStepId, TStepState, TSchemaOut>(
  step: Step<TStepId, SubsetOf<TStepState, TState>, TPrevSchema, TSchemaOut, any, any, TEngineType>
): Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TSchemaOut>;

// Usage:
const workflow = createWorkflow({ id: "my-wf", inputSchema, outputSchema })
  .then(stepA)  // First step receives workflow input
  .then(stepB)  // Receives stepA output (must match stepB.inputSchema)
  .then(stepC)  // Receives stepB output
  .commit();    // Finalizes workflow for execution

// Type safety: TPrevSchema flows through
// stepB.inputSchema must be compatible with stepA.outputSchema
// If they don't match, you need .map() between them
```

**Satisfies PR-2?** ✅ YES - Simple fluent API for sequential chaining.

**Decisions We Control:**
- Whether to auto-insert `.map()` when schemas don't match exactly
- How to represent sequential edges in our visual model

**Actionable Primitive:**
```typescript
// Linear workflow generation
function generateLinearWorkflow(nodes: WorkflowNode[], edges: WorkflowEdge[]): string {
  const orderedNodes = topologicalSort(nodes, edges);
  
  let code = `const workflow = createWorkflow({ 
    id: "${workflowId}", 
    inputSchema, 
    outputSchema 
  })`;
  
  for (const node of orderedNodes) {
    code += `\n  .then(${node.id}Step)`;
    
    // If next node has mapping, insert .map()
    const outEdge = edges.find(e => e.source === node.id);
    if (outEdge?.data?.mappings?.length > 0) {
      code += `\n  ${generateMappingCode(outEdge)}`;
    }
  }
  
  code += `\n  .commit();`;
  return code;
}
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 106-107

---

### RQ-5: How do we run steps in parallel?

**Maps to Requirement:** PR-6 (Control Flow) - Some workflows need parallel execution.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** What is the `.parallel()` method signature? How do outputs merge?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts

parallel<TParallelSteps extends readonly Step[]>(
  steps: TParallelSteps
): Workflow<..., z.ZodObject<{ 
  [K in keyof StepsRecord<TParallelSteps>]: StepsRecord<TParallelSteps>[K]["outputSchema"] 
}>>;

// Usage:
const workflow = createWorkflow({ ... })
  .then(stepA)
  .parallel([stepB, stepC, stepD])  // All receive stepA output, run concurrently
  .then(stepE);  // Receives merged output: { stepB: {...}, stepC: {...}, stepD: {...} }

// Output structure after .parallel():
// {
//   stepB: <stepB.outputSchema>,
//   stepC: <stepC.outputSchema>,
//   stepD: <stepD.outputSchema>,
// }

// You typically need .map() after parallel to flatten/restructure:
.parallel([stepB, stepC])
.map({
  combinedField: {
    fn: async ({ inputData }) => ({
      fromB: inputData.stepB.field,
      fromC: inputData.stepC.field,
    }),
    schema: z.object({ fromB: z.string(), fromC: z.string() }),
  },
})
.then(stepE)
```

**Satisfies PR-6?** ✅ YES - Native parallel execution with automatic output merging.

**Decisions We Control:**
- Visual representation of parallel branches (fan-out/fan-in)
- Whether to auto-generate `.map()` after parallel to flatten outputs

**Actionable Primitive:**
```typescript
// Detect parallel branches from visual editor
function detectParallelBranches(nodes: WorkflowNode[], edges: WorkflowEdge[]): ParallelGroup[] {
  // Find nodes with same source (fan-out)
  const fanOutGroups = new Map<string, string[]>();
  for (const edge of edges) {
    const targets = fanOutGroups.get(edge.source) || [];
    targets.push(edge.target);
    fanOutGroups.set(edge.source, targets);
  }
  
  return Array.from(fanOutGroups.entries())
    .filter(([_, targets]) => targets.length > 1)
    .map(([source, targets]) => ({ source, parallelSteps: targets }));
}

// Generate: .parallel([stepB, stepC, stepD])
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 139-141

---

### RQ-6: How do we branch conditionally?

**Maps to Requirement:** PR-6 (Control Flow) - If/else logic based on step output.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** What is the `.branch()` or conditional method signature?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts

// Condition function signature:
type ConditionFunction<TState, TStepInput, TResumeSchema, TSuspendSchema, EngineType> = 
  (params: ExecuteFunctionParams<...>) => Promise<boolean>;

// .branch() method:
branch<TBranchSteps extends Array<[ConditionFunction, Step]>>(
  steps: TBranchSteps
): Workflow<...>;

// Usage:
const workflow = createWorkflow({ ... })
  .then(stepA)
  .branch([
    [
      async ({ inputData }) => inputData.priority === "high",
      urgentStep,
    ],
    [
      async ({ inputData }) => inputData.priority === "low",
      normalStep,
    ],
    [
      async () => true,  // Default/else branch (always true)
      defaultStep,
    ],
  ])
  .then(stepAfterBranch);

// Conditions are evaluated in order, first match wins
// Only ONE branch executes
// Output is keyed by executed step ID

// Also available: loops
.dowhile(step, condition)   // Execute while condition is true (check after)
.dountil(step, condition)   // Execute until condition is true (check after)
.foreach(step, { concurrency: 5 })  // Iterate over array output
```

**Satisfies PR-6?** ✅ YES - Full conditional branching with condition functions.

**Decisions We Control:**
- UI for defining condition expressions (code vs visual)
- Whether to support complex conditions in MVP or just simple field comparisons
- How to visualize conditional branches (color coding, labels)

**Actionable Primitive:**
```typescript
// Visual condition → code
function generateConditionCode(condition: VisualCondition): string {
  if (condition.type === 'simple') {
    // { field: "priority", operator: "equals", value: "high" }
    return `async ({ inputData }) => inputData.${condition.field} ${condition.operator} ${JSON.stringify(condition.value)}`;
  } else if (condition.type === 'expression') {
    // Raw JS expression for advanced users
    return `async ({ inputData }) => ${condition.expression}`;
  }
}

// Generate branch code:
function generateBranchCode(branches: ConditionalBranch[]): string {
  const branchCode = branches.map(b => 
    `[${generateConditionCode(b.condition)}, ${b.stepId}Step]`
  ).join(',\n    ');
  
  return `.branch([\n    ${branchCode}\n  ])`;
}
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 142-145, `step.d.ts` lines 46-49

---

### RQ-7: How are errors handled?

**Maps to Requirement:** PR-11 (Error Handling) - When a Composio tool fails, users need to see which step failed and why.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Questions:**
1. How do we catch errors from a step?
2. What error object/type is thrown?
3. Can we retry a failed step without re-running the whole workflow?
4. Can we set timeouts per step?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/types.d.ts

// Step result states:
type StepResult<P, R, S, T> = 
  | StepSuccess<P, R, S, T>   // { status: 'success', output: T, startedAt, endedAt }
  | StepFailure<P, R, S>      // { status: 'failed', error: string | Error, startedAt, endedAt }
  | StepSuspended<P, S>       // { status: 'suspended', suspendPayload, suspendedAt }
  | StepRunning<P, R, S>      // { status: 'running', startedAt }
  | StepWaiting<P, R, S>;     // { status: 'waiting', startedAt }

// Workflow result states:
type WorkflowResult<TState, TInput, TOutput, TSteps> = 
  | { status: 'success'; result: TOutput; steps: StepsRecord; }
  | { status: 'failed'; error: Error; steps: StepsRecord; }
  | { status: 'suspended'; suspendPayload: any; suspended: [string[], ...string[][]]; steps: StepsRecord; };

// Error details available per step:
steps: {
  [stepId]: {
    status: 'failed';
    error: string | Error;  // ← Actual error message/object
    payload: any;           // ← Input that caused the error
    startedAt: number;      // ← Timestamp
    endedAt: number;        // ← Timestamp
  }
}

// Retry configuration:
// Per-step:
const step = createStep({
  id: "my-step",
  retries: 3,  // ← Retry up to 3 times on failure
  // ...
});

// Per-workflow:
const workflow = createWorkflow({
  id: "my-wf",
  retryConfig: {
    attempts: 3,   // ← Global retry count
    delay: 1000,   // ← Delay between retries (ms)
  },
  // ...
});

// Manual error handling in execute:
execute: async ({ inputData, abort, bail }) => {
  try {
    const result = await riskyOperation();
    return result;
  } catch (error) {
    if (error.code === 'RATE_LIMITED') {
      // bail() exits with a result (not failure)
      return bail({ success: false, reason: 'rate_limited' });
    }
    // Re-throw for normal failure handling
    throw error;
  }
}

// abort() cancels the entire workflow
// bail() exits with a result (success status, not failure)
```

**Satisfies PR-11?** ✅ YES - Per-step error tracking with status, error message, and timing.

**Decisions We Control:**
- Default retry count for Composio tool steps
- UI for displaying step errors (inline vs modal)
- Whether to support conditional retry logic

**Actionable Primitive:**
```typescript
// Workflow execution with error visibility:
const run = await workflow.createRunAsync();
const result = await run.start({ inputData: {...} });

if (result.status === 'failed') {
  // Find which step failed
  const failedSteps = Object.entries(result.steps)
    .filter(([_, step]) => step.status === 'failed')
    .map(([id, step]) => ({
      stepId: id,
      error: step.error,
      input: step.payload,
      startedAt: new Date(step.startedAt),
      endedAt: new Date(step.endedAt),
    }));
  
  // Display in UI
  displayErrorDetails(failedSteps);
}
```

**Source:** `@mastra/core/dist/workflows/types.d.ts` lines 17-67, 284-321

---

### RQ-8: How do we execute a workflow?

**Maps to Requirement:** PR-10 (Testing) - Need to run workflow with test inputs and see step-by-step results.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Questions:**
1. What method executes a workflow?
2. How do we pass inputs?
3. Can we get step-by-step results (not just final output)?

**External Truth Discovered:**

```typescript
// From @mastra/core/dist/workflows/workflow.d.ts

// 1. Create a run instance (async required for persistence)
const run = await workflow.createRunAsync({
  runId?: string;        // Optional custom run ID
  resourceId?: string;   // Optional resource association
  disableScorers?: boolean;
});

// 2. Execute with input
const result = await run.start({
  inputData: { email: "test@example.com", subject: "Hello" },
  initialState?: { ... },           // Optional initial shared state
  runtimeContext?: RuntimeContext,  // Dependency injection
  tracingOptions?: TracingOptions,  // Observability
  outputOptions?: {
    includeState?: boolean,         // Include final state in result
    includeResumeLabels?: boolean,  // Include suspension points
  },
});

// 3. Streaming execution for real-time updates
const { result, stream } = run.stream({
  inputData: { ... },
  closeOnSuspend?: boolean,  // Close stream on suspension
});

// Observe stream events:
for await (const event of stream) {
  // Event types: 'step-result', 'step-suspended', 'step-waiting', etc.
  if (event.type === 'step-result') {
    console.log(`Step ${event.id} completed:`, event.payload);
  }
}

const finalResult = await result;

// 4. Watch for real-time updates (alternative to streaming)
run.watch((event: WatchEvent) => {
  console.log('Current step:', event.payload.currentStep);
  console.log('All steps:', event.payload.workflowState.steps);
}, 'watch');

// 5. Access step results from final output
result.steps = {
  [stepId]: {
    status: 'success' | 'failed' | 'suspended' | ...;
    output: { ... };      // Step output data
    payload: { ... };     // Step input data
    startedAt: number;
    endedAt: number;
  }
}

// 6. Resume from suspension (human-in-the-loop)
const resumedResult = await run.resume({
  resumeData: { approvalStatus: 'approved' },
  step: suspendedStep,  // Which step to resume
});
```

**Satisfies PR-10?** ✅ YES - Full step-by-step visibility with streaming and watch APIs.

**Decisions We Control:**
- Whether to use streaming or polling for test execution UI
- What result details to display (timing, input/output, errors)
- How to handle long-running tests

**Actionable Primitive:**
```typescript
// Test execution in workflow editor
async function executeWorkflowTest(
  workflow: Workflow,
  testInput: Record<string, unknown>,
  onStepComplete: (stepId: string, result: StepResult) => void
): Promise<WorkflowResult> {
  const run = await workflow.createRunAsync();
  
  // Use streaming for real-time updates
  const { result, stream } = run.stream({ inputData: testInput });
  
  for await (const event of stream) {
    if (event.type === 'step-result') {
      onStepComplete(event.id, event.payload);
    }
  }
  
  return await result;
}
```

**Source:** `@mastra/core/dist/workflows/workflow.d.ts` lines 181-186, 340-412

---

### RQ-9: Does Mastra require code files or accept runtime definitions?

**Maps to Requirement:** Architecture - Determines if we code-gen `.ts` files or build workflows in memory.

**Status:** ✅ Verified from `@mastra/core@0.24.6`

**Question:** Can we define and execute a workflow without writing to disk?

**External Truth Discovered:**

```typescript
// From @mastra/core source analysis

// Workflows are JavaScript objects, NOT file-based
// createWorkflow() returns a Workflow instance that can be executed immediately

const workflow = createWorkflow({
  id: "dynamic-workflow",
  inputSchema: z.object({ ... }),
  outputSchema: z.object({ ... }),
})
.then(createStep({
  id: "step1",
  inputSchema: z.object({ ... }),
  outputSchema: z.object({ ... }),
  execute: async ({ inputData }) => {
    // Dynamic execution logic
    return { ... };
  },
}))
.commit();

// Execute immediately - no file I/O required
const run = await workflow.createRunAsync();
const result = await run.start({ inputData: { ... } });

// Key evidence:
// 1. No file paths in WorkflowConfig
// 2. execute functions are passed as closures
// 3. Workflow class extends MastraBase (in-memory)
// 4. createRunAsync() creates an execution context in memory

// HOWEVER: execute functions must be JavaScript
// We cannot pass a "tool reference" and have Mastra resolve it
// The execute function must contain the actual implementation
```

**Architectural Impact:** 

| Option | Supported? | Notes |
|--------|------------|-------|
| Code files (`.ts`) | ✅ Yes | Standard approach, can use imports |
| Runtime definition | ✅ Yes | Must construct execute functions dynamically |
| Pure JSON definition | ❌ No | Cannot serialize execute functions |

**Decisions We Control:**
- **Option A: Code Generation** - Generate `.ts` files that can be imported and executed. Safer, supports IDE features, version control.
- **Option B: Dynamic Construction** - Build workflows at runtime using `eval()` or `new Function()`. More flexible, but security concerns.
- **Recommended: Code Generation** for production workflows, with optional dynamic execution for testing in the editor.

**Source:** Analysis of `@mastra/core/dist/workflows/workflow.d.ts` constructor and execution model

---

## Part 2: Composio Research

### RQ-10: Does Composio expose output schemas?

**Maps to Requirement:** PR-1 (Node Discovery), PR-3 (Connection Validation) - We need to know what a tool returns to validate connections.

**Status:** ✅ Verified from `@composio/client@1.0.4`

**Question:** When we fetch a tool, does it include an output schema? If not, what are our options?

**External Truth Discovered:**

```typescript
// From @composio/client/resources/tools.d.ts

interface ToolRetrieveResponse {
  slug: string;
  name: string;
  description: string;
  
  // ✅ INPUT SCHEMA - JSON Schema format
  input_parameters: { [key: string]: unknown };
  
  // ✅ OUTPUT SCHEMA EXISTS!
  output_parameters: { [key: string]: unknown };
  
  // Toolkit info for connection detection
  toolkit: {
    slug: string;   // e.g., "gmail"
    name: string;   // e.g., "Gmail"
    logo: string;
  };
  
  no_auth: boolean;
  version: string;
  tags: string[];
  scopes: string[];
}

// Execution response:
interface ToolExecuteResponse {
  successful: boolean;
  error: string | null;
  data: { [key: string]: unknown };  // Actual output
  log_id?: string;
  session_info?: unknown;
}

// Example output_parameters (hypothetical Gmail Send):
// {
//   "type": "object",
//   "properties": {
//     "messageId": { "type": "string" },
//     "threadId": { "type": "string" }
//   }
// }
```

**Satisfies PR-1, PR-3?** ✅ YES - Composio DOES expose `output_parameters`! This is better than expected.

**Current Implementation Gap:**
Our current `composio-tools.ts` doesn't use `output_parameters` - it only converts `input_parameters`. We should update it.

**Workaround Options (if output_parameters is empty for some tools):**

| Option | Pros | Cons |
|--------|------|------|
| A: Use output_parameters when available | Type-safe | Some tools may not have it |
| B: Fallback to `z.record(z.string(), z.any())` | Always works | No specific type info |
| C: Manual schema definition | Full control | Maintenance burden |
| D: Infer from successful execution | Learn from runtime | Only works after first run |

**Decisions We Control:**
- Primary: Use `output_parameters` from Composio
- Fallback: Use `z.record(z.string(), z.any())` for tools without output schemas
- Display: Show "Output schema unknown" in UI for fallback cases

**Actionable Primitive:**
```typescript
// Updated schema extraction
async function getComposioToolSchemas(toolSlug: string) {
  const client = getComposioClient();
  const tool = await client.tools.retrieve(toolSlug);
  
  return {
    inputSchema: convertJsonSchemaToZod(tool.input_parameters),
    outputSchema: tool.output_parameters 
      ? convertJsonSchemaToZod(tool.output_parameters)
      : z.record(z.string(), z.any()),  // Fallback
    hasOutputSchema: !!tool.output_parameters,
    toolkit: tool.toolkit.slug,
  };
}
```

**Source:** `@composio/client/resources/tools.d.ts` lines 79-130, 278-301

---

### RQ-11: How do we get toolkit from tool?

**Maps to Requirement:** PR-4 (Connection Requirements) - When user adds a Gmail tool, we auto-detect "Requires Gmail".

**Status:** ✅ Verified from `@composio/client@1.0.4`

**Question:** Given a tool like `GMAIL_SEND_EMAIL`, how do we extract `gmail` as the toolkit?

**External Truth Discovered:**

```typescript
// From @composio/client/resources/tools.d.ts

// Tool response includes toolkit info:
interface ToolRetrieveResponse {
  // ...
  toolkit: {
    slug: string;   // "gmail" ← This is what we need
    name: string;   // "Gmail"
    logo: string;   // URL to logo
  };
}

// Also in list response:
interface ToolListResponse.Item {
  // ...
  toolkit: {
    slug: string;
    name: string;
    logo: string;
  };
}

// Our existing ConnectionToolBinding already captures this:
type ConnectionToolBinding = {
  toolId: string;        // "GMAIL_SEND_EMAIL"
  connectionId: string;  // "ca_abc123"
  toolkitSlug: string;   // "gmail" ← We already store this!
};
```

**Satisfies PR-4?** ✅ YES - Toolkit info is directly available from tool metadata.

**Decisions We Control:**
- How to aggregate unique toolkits from workflow steps
- How to display connection requirements (badges, list, icons)

**Actionable Primitive:**
```typescript
// Extract required connections from workflow
function getRequiredConnections(workflow: WorkflowDefinition): RequiredConnection[] {
  const toolkitMap = new Map<string, { name: string; logo: string; tools: string[] }>();
  
  for (const node of workflow.nodes) {
    if (node.data.type === 'composio-tool') {
      const existing = toolkitMap.get(node.data.toolkitSlug) || {
        name: node.data.toolkitName,
        logo: node.data.toolkitLogo,
        tools: [],
      };
      existing.tools.push(node.data.toolId);
      toolkitMap.set(node.data.toolkitSlug, existing);
    }
  }
  
  return Array.from(toolkitMap.entries()).map(([slug, info]) => ({
    toolkitSlug: slug,
    toolkitName: info.name,
    toolkitLogo: info.logo,
    requiredTools: info.tools,
  }));
}
```

**Source:** `@composio/client/resources/tools.d.ts` lines 159-173, `@/_tables/types.ts`

---

### RQ-12: How do we wrap Composio tools as Mastra steps?

**Maps to Requirement:** PR-2 (IPO Model), PR-4 (Connection Requirements) - Core integration pattern.

**Status:** ✅ Verified from existing codebase + package analysis

**Questions:**
1. Can Composio tools be used directly as Mastra steps?
2. How do we pass `connectionId` to the tool execution?
3. Is there an official integration?

**External Truth Discovered:**

```typescript
// 1. Official integration EXISTS but is INCOMPATIBLE
// @composio/mastra requires @mastra/core@^0.21.x
// We use @mastra/core@0.24.6 → Schema incompatibility
// See: _docs/_diary/21-ComposioMastraArchitectureRefactor.md

// 2. Current workaround (composio-tools.ts):
// - Manual JSON Schema → Zod conversion
// - Wrap execution in Vercel AI SDK tool()
// - Works with Mastra agent.stream()

// 3. For workflows, we need to wrap as Mastra Step:
import { createStep } from "@mastra/core";
import { getComposioClient } from "./composio";

function createComposioStep(toolId: string, connectionId: string, toolkitSlug: string) {
  // Fetch tool metadata for schemas
  const client = getComposioClient();
  const tool = await client.tools.retrieve(toolId);
  
  return createStep({
    id: `composio-${toolId.toLowerCase()}`,
    description: tool.description,
    inputSchema: convertJsonSchemaToZod(tool.input_parameters),
    outputSchema: tool.output_parameters 
      ? convertJsonSchemaToZod(tool.output_parameters)
      : z.record(z.string(), z.any()),
    
    execute: async ({ inputData, resourceId }) => {
      const result = await client.tools.execute(toolId, {
        arguments: inputData,
        connected_account_id: connectionId,
        user_id: resourceId,  // Map Mastra resourceId to Composio userId
      });
      
      if (!result.successful) {
        throw new Error(result.error || `Tool ${toolId} execution failed`);
      }
      
      return result.data;
    },
  });
}

// 4. Key insight: connectionId is WORKFLOW CONFIGURATION, not runtime input
// When a workflow is saved, it stores which connectionId to use
// At execution time, that connectionId is baked into the step
```

**Satisfies PR-2, PR-4?** ✅ YES - We can wrap Composio tools as fully-typed Mastra steps.

**Decisions We Control:**
- Whether connectionId is per-workflow or per-step (workflow-level is simpler)
- How to handle tools that require no auth
- Error message formatting

**Actionable Primitive:**
```typescript
// Code generation for Composio tool step
function generateComposioStepCode(
  node: WorkflowNode,
  connectionId: string
): string {
  return `
const ${node.id}Step = createStep({
  id: "${node.id}",
  description: "${node.data.description}",
  inputSchema: ${generateZodFromJsonSchema(node.data.inputSchema)},
  outputSchema: ${generateZodFromJsonSchema(node.data.outputSchema)},
  execute: async ({ inputData, resourceId }) => {
    const client = getComposioClient();
    const result = await client.tools.execute("${node.data.toolId}", {
      arguments: inputData,
      connected_account_id: "${connectionId}",
      user_id: resourceId,
    });
    
    if (!result.successful) {
      throw new Error(result.error || "Tool execution failed");
    }
    
    return result.data;
  },
});`;
}
```

**Source:** `app/api/tools/services/composio-tools.ts`, `@composio/client/resources/tools.d.ts`, `@mastra/core/dist/workflows/workflow.d.ts`

---

## Part 3: Architectural Decisions

These are **decisions we make**, not facts to discover. But they must be grounded in external truth.

### OQ-1: Code-Gen vs Runtime Interpretation

**Question:** Do we generate Mastra `.ts` files, or interpret workflow definitions at runtime?

**External Truth That Constrains This:**
- Mastra workflows require JavaScript `execute` functions (RQ-9)
- Cannot serialize closures to JSON
- Mastra does support in-memory workflow construction

**Options:**

| Option | Pros | Cons |
|--------|------|------|
| **Code-Gen** | Type-safe, IDE support, version control, debugging | File I/O, build step needed |
| **Runtime** | Instant testing, no build | Security (eval), no IDE support, harder to debug |
| **Hybrid** | Best of both | More complexity |

**Decision:** ✅ **Hybrid Approach**

**Rationale:**
1. **Development/Testing**: Runtime construction for instant preview in editor
2. **Production**: Generate `.ts` files for deployment

**Implementation Impact:**
```typescript
// 1. Visual editor stores JSON representation
interface WorkflowDefinition {
  id: string;
  nodes: WorkflowNode[];
  edges: WorkflowEdge[];
  config: WorkflowConfig;
}

// 2. For testing: Construct at runtime
function constructWorkflowForTest(def: WorkflowDefinition): Workflow {
  const workflow = createWorkflow({ ... });
  // Dynamically add steps
  return workflow.commit();
}

// 3. For production: Generate code
function generateWorkflowCode(def: WorkflowDefinition): string {
  return `
import { createWorkflow, createStep } from "@mastra/core";
// ... generated code
export const ${def.id}Workflow = createWorkflow({ ... });
`;
}
```

---

### OQ-2: How to handle missing output schemas?

**Question:** If Composio doesn't expose output schemas for some tools, how do we handle type validation?

**External Truth That Constrains This:**
- Composio DOES provide `output_parameters` (RQ-10) ✅
- Some tools may have empty output schemas
- Mastra steps require `outputSchema` (RQ-2)

**Options:**

| Option | Pros | Cons |
|--------|------|------|
| Use output_parameters | Type-safe | May be incomplete |
| Fallback to z.record() | Always works | No validation |
| Manual override | Full control | Maintenance |
| Skip output validation | Simple | Type errors downstream |

**Decision:** ✅ **Use output_parameters with z.record() fallback**

**Rationale:**
1. Primary: Use Composio's `output_parameters` when available
2. Fallback: `z.record(z.string(), z.any())` for unknown outputs
3. Display: UI indicates when output schema is inferred vs explicit

**Implementation Impact:**
```typescript
function getStepOutputSchema(toolId: string): { schema: z.ZodType; isExact: boolean } {
  const tool = await composio.tools.retrieve(toolId);
  
  if (tool.output_parameters && Object.keys(tool.output_parameters).length > 0) {
    return {
      schema: convertJsonSchemaToZod(tool.output_parameters),
      isExact: true,
    };
  }
  
  return {
    schema: z.record(z.string(), z.any()),
    isExact: false,
  };
}
```

---

### OQ-3: Data transforms in mappings?

**Question:** Do we support inline transforms (e.g., `salary.min + "-" + salary.max`), or just direct field mapping?

**External Truth That Constrains This:**
- Mastra `.map()` supports function transforms (RQ-3)
- Functions must be JavaScript (executable)
- Type safety requires schema declarations

**Options:**

| Option | Complexity | User Power |
|--------|------------|------------|
| Direct mapping only | Low | Low |
| Simple transforms | Medium | Medium |
| Full expressions | High | High |

**Decision:** ✅ **Direct mapping for MVP, simple transforms for v2**

**Rationale:**
1. MVP: Direct field mapping (`{ targetField: { step: sourceStep, path: "sourceField" } }`)
2. MVP: Literal values (`{ targetField: { value: "constant", schema: z.string() } }`)
3. v2: Simple transforms (`{ fn: ({ inputData }) => inputData.a + inputData.b, schema: z.number() }`)
4. Future: Expression builder UI

**Implementation Impact:**
```typescript
// MVP: Simple mapping UI
interface FieldMapping {
  type: 'direct' | 'literal';
  targetField: string;
  sourceStep?: string;
  sourcePath?: string;
  literalValue?: unknown;
  literalSchema?: string;  // "string" | "number" | etc.
}

// v2: Add transform support
interface FieldMappingV2 extends FieldMapping {
  type: 'direct' | 'literal' | 'transform';
  transformExpression?: string;  // Simple expression like "a + b"
  transformSchema?: string;
}
```

---

## Part 4: Summary & Primitives Table

### Primitives We'll Use

| What | Primitive | Signature | Source | Verified? |
|------|-----------|-----------|--------|-----------|
| Define workflow | `createWorkflow()` | `(config: WorkflowConfig) => Workflow` | Mastra | ✅ |
| Define step | `createStep()` | `(params: StepParams) => Step` | Mastra | ✅ |
| Chain steps | `.then()` | `(step: Step) => Workflow` | Mastra | ✅ |
| Parallel | `.parallel()` | `(steps: Step[]) => Workflow` | Mastra | ✅ |
| Branch | `.branch()` | `([ [cond, step], ... ]) => Workflow` | Mastra | ✅ |
| Data mapping | `.map()` | `(config: MappingConfig) => Workflow` | Mastra | ✅ |
| Commit | `.commit()` | `() => Workflow` | Mastra | ✅ |
| Execute | `.createRunAsync()` | `(opts?) => Promise<Run>` | Mastra | ✅ |
| Stream results | `run.stream()` | `(input) => { result, stream }` | Mastra | ✅ |
| Fetch tool | `client.tools.retrieve()` | `(slug) => ToolRetrieveResponse` | Composio | ✅ |
| Input schema | `tool.input_parameters` | `{ [key]: JsonSchema }` | Composio | ✅ |
| Output schema | `tool.output_parameters` | `{ [key]: JsonSchema }` | Composio | ✅ |
| Toolkit info | `tool.toolkit.slug` | `string` | Composio | ✅ |
| Execute tool | `client.tools.execute()` | `(slug, params) => ToolExecuteResponse` | Composio | ✅ |

### Key Decisions Made

| Decision | Choice | Date | Grounded In |
|----------|--------|------|-------------|
| Code-Gen vs Runtime | Hybrid (runtime test, codegen prod) | 2025-12-06 | RQ-9 |
| Output schema handling | Use output_parameters + z.record() fallback | 2025-12-06 | RQ-10 |
| Data transforms | Direct mapping MVP, transforms v2 | 2025-12-06 | RQ-3 |

### Blockers & Issues

| Issue | Impact | Resolution |
|-------|--------|------------|
| @composio/mastra incompatible | Cannot use official integration | Manual wrapping ✅ |
| Some tools lack output_parameters | Reduced type safety | z.record() fallback ✅ |

### Research Completion Checklist

- [x] All RQ questions answered with external truth
- [x] All OQ decisions made and grounded
- [x] Primitives table complete with verified signatures
- [x] No assumptions - everything verified against docs/code

---

## Research Log

| Timestamp | Action | Finding |
|-----------|--------|---------|
| 2025-12-06 10:00 | Read @mastra/core workflow.d.ts | Full workflow API discovered |
| 2025-12-06 10:15 | Read @mastra/core step.d.ts | Step interface and execute params |
| 2025-12-06 10:30 | Read @mastra/core types.d.ts | StepResult, WorkflowResult types |
| 2025-12-06 10:45 | Read @composio/client tools.d.ts | **output_parameters EXISTS** ✅ |
| 2025-12-06 11:00 | Reviewed composio-tools.ts | Current manual conversion approach |
| 2025-12-06 11:15 | Architecture decisions | Hybrid code-gen, output schema fallback |
| 2025-12-06 14:00 | Cross-researcher review | Resolved output_parameters discrepancy |
| 2025-12-06 14:15 | Product owner review | Terminal vs non-terminal node concept |
| 2025-12-06 14:30 | Reviewed _tables/tools/hohoho | Understood existing tool generation pattern |
| 2025-12-06 14:45 | Generated workflow.ts example | Documented exact shape of output file |
| 2025-12-06 15:00 | Visual→Primitive mapping | Clarified .map() is the "line" concept |
| 2025-12-06 15:15 | List view data flow | Identified as open UX question |
| 2025-12-06 15:30 | Composability discussion | Steps can be imported across workflows |
| 2025-12-06 16:00 | Live Composio query | outputParameters verified - all tools have it |
| 2025-12-06 16:15 | Schema deep dive | Most use generic wrapper, some have rich schemas |
| 2025-12-06 16:30 | workflow.json schema | Proposed structure for editor state → code gen |

---

## Part 5: Conversation Insights (Dec 6, 2025)

These insights emerged from reviewing the research with the product owner and comparing notes with a parallel researcher.

### Clarification: Output Parameters Discrepancy (RESOLVED)

**The Issue:** One researcher claimed Composio doesn't expose output schemas. This research found they do exist.

**Resolution:** The `outputParameters` field **does exist** and **is populated**.

**Verified via Live Query (Dec 6, 2025):**

```bash
# Script: scripts/check-composio-output.ts
npx tsx scripts/check-composio-output.ts
```

**Results:**

| Tool | outputParameters Fields |
|------|------------------------|
| GMAIL_ADD_LABEL_TO_EMAIL | 3 fields: `data`, `error`, `successful` |
| FIRECRAWL_CRAWL | 11 fields: `completed`, `creditsUsed`, `data`, `error`, `expiresAt`, etc. |
| FIRECRAWL_CRAWL_V2 | 9 fields: `completed`, `creditsUsed`, `data`, `error`, `expiresAt`, etc. |
| GITHUB_ACCEPT_A_REPOSITORY_INVITATION | 3 fields: `data`, `error`, `successful` |
| SLACK_ADD_A_CUSTOM_EMOJI_TO_A_SLACK_TEAM | 3 fields: `data`, `error`, `successful` |

**Key Insight:** 

1. **All tools have outputParameters** - Every tool has at least 3 fields
2. **Most are generic wrappers** - Standard pattern: `{ data: object, error: string, successful: boolean }`
3. **Some tools have rich schemas** - Firecrawl provides typed fields like `completed: integer`, `creditsUsed: integer`
4. **The "data" field is usually untyped** - It's `type: object` without properties

**What This Means for Workflow Editor:**

| Scenario | Output Schema | Data Mapping |
|----------|---------------|--------------|
| Rich schema (Firecrawl) | Use typed fields directly | `{ step: scrapeStep, path: "creditsUsed" }` |
| Generic wrapper | Can validate `successful: boolean` | Access `data.*` at runtime |
| Terminal node (Send Email) | Only need `successful` check | No downstream mapping needed |

**Design Decision:** For generic `data: object` outputs, our visual editor should:
1. Show the known fields (`data`, `error`, `successful`)
2. Allow users to type dotted paths for `data.*` properties
3. Validate at runtime, not design time

**Note:** Field is `outputParameters` (camelCase) when using `getRawComposioTools()`, not `output_parameters` (snake_case).

---

### New Concept: Terminal vs Non-Terminal Nodes

**Insight from product owner:** Not all nodes need output schemas.

| Node Type | Example | Output Schema Needed? |
|-----------|---------|----------------------|
| **Terminal** | Send Email, Post Tweet | No - it's the end of a branch |
| **Non-Terminal** | Fetch Emails, Scrape URL | Yes - downstream nodes depend on shape |

**UX Implication:** 
- Don't show "Output: unknown" as an error for terminal nodes
- Only flag missing output schemas on non-terminal nodes where it actually matters
- Visual indicator: terminal nodes could have a different appearance (no output handle?)

---

### The Shape of Generated Files

**Question:** What does a transpiled Mastra workflow actually look like?

**Answer:** Based on the existing `_tables/tools/` pattern (see `hohoho/`), workflows would have:

```
_tables/workflows/
  job-application-workflow/
    workflow.json     ← Visual editor state (nodes, edges, positions)
    workflow.ts       ← Generated Mastra code (executable)
```

**Example Generated `workflow.ts`:**

```typescript
import { createWorkflow, createStep } from "@mastra/core";
import { z } from "zod";
import { getComposioClient } from "@/app/api/connections/services/composio";

// Step definitions
const scrapeJobStep = createStep({
  id: "scrape-job",
  description: "Scrapes a job listing URL",
  inputSchema: z.object({
    url: z.string().url(),
  }),
  outputSchema: z.object({
    title: z.string(),
    company: z.string(),
    requirements: z.array(z.string()),
  }),
  execute: async ({ inputData, resourceId }) => {
    const client = getComposioClient();
    const result = await client.tools.execute("FIRECRAWL_SCRAPE_URL", {
      arguments: { url: inputData.url },
      connected_account_id: "{{connectionId:firecrawl}}",
      user_id: resourceId,
    });
    return result.data;
  },
});

const generateResumeStep = createStep({
  id: "generate-resume",
  inputSchema: z.object({
    jobTitle: z.string(),
    companyName: z.string(),
    targetSkills: z.array(z.string()),
    baseResume: z.string(),
  }),
  outputSchema: z.object({
    tailoredResume: z.string(),
  }),
  execute: async ({ inputData, resourceId }) => {
    // ... execution logic
  },
});

// Workflow composition
export const jobApplicationWorkflow = createWorkflow({
  id: "job-application-workflow",
  inputSchema: z.object({
    url: z.string().url(),
    baseResume: z.string(),
  }),
  outputSchema: z.object({
    tailoredResume: z.string(),
  }),
})
  .then(scrapeJobStep)
  .map({
    jobTitle: { step: scrapeJobStep, path: "title" },
    companyName: { step: scrapeJobStep, path: "company" },
    targetSkills: { step: scrapeJobStep, path: "requirements" },
    baseResume: { initData: jobApplicationWorkflow, path: "baseResume" },
  })
  .then(generateResumeStep)
  .commit();
```

**Key Observations:**
- Steps are defined separately, then composed
- `.map()` is the explicit data mapping (what we visualize as "lines")
- `{{connectionId:firecrawl}}` placeholders get resolved when workflow is "hired"

---

### Visual Concept → Mastra Primitive Mapping

| Visual Editor Concept | Mastra Primitive | Code Pattern |
|----------------------|------------------|--------------|
| A node on canvas | `Step` | `createStep({ id, inputSchema, outputSchema, execute })` |
| A line between nodes | `.map()` | `{ targetField: { step: sourceStep, path: "field" } }` |
| The workflow itself | `Workflow` | `createWorkflow({ id, inputSchema, outputSchema })` |
| Sequential edge (no mapping needed) | `.then()` | When output schema === next input schema exactly |
| Sequential edge (mapping needed) | `.then()` + `.map()` | When fields need renaming/restructuring |
| Fork to parallel paths | `.parallel()` | `.parallel([stepA, stepB])` |
| If/else branch | `.branch()` | `.branch([[condition, step], ...])` |
| Finalize | `.commit()` | Always called at end |

**Important Clarification:** 
- `.then()` alone assumes output schema matches input schema exactly
- If you need to rename `title` → `jobTitle`, you insert `.map()` between `.then()` calls
- This is the visual "line" - it's not just a connection, it's a transformation specification

---

### Open Question: Data Flow in List View

**The Problem:** In a node/canvas view, data mapping is visualized as lines connecting output fields to input fields. In a list/timeline view, there are no explicit lines.

**Question:** How do we elegantly show "Step 2.jobTitle comes from Step 1.title" in a list view?

**Potential Solutions:**

| Approach | Description | Pros | Cons |
|----------|-------------|------|------|
| Inline badges | Show "← Step 1.title" next to each input field | Clear, explicit | Verbose, clutters UI |
| Hover/expand | Expand step to see mapping details | Clean default | Hidden complexity |
| Separate panel | Click edge indicator to see mapping in sidebar | Keeps list clean | Extra click |
| Don't show in list | List view is overview-only, use canvas for mapping | Simple | Forces view switching |

**Decision:** TBD - requires UX exploration. May differ based on user expertise level.

---

### Composability: Tools as Importable Steps

**Insight:** If we break workflows into separate step files, we enable reuse.

**Example:** The "Scrape Job Listing" step could exist as:
1. A standalone **Tool** (single step, callable by agents directly)
2. A **Step** imported into multiple workflows

**File Structure for Composability:**

```
_tables/
  tools/
    scrape-job-listing/
      tool.ts           ← Standalone tool definition
      tool.json         ← Metadata
  workflows/
    job-application/
      workflow.ts       ← Imports scrape-job-listing step
      workflow.json
    job-tracker/
      workflow.ts       ← Also imports scrape-job-listing step
      workflow.json
```

**Code Pattern:**

```typescript
// In workflow.ts
import { scrapeJobStep } from "@/_tables/tools/scrape-job-listing/tool";

export const jobApplicationWorkflow = createWorkflow({ ... })
  .then(scrapeJobStep)  // Reused step
  .map({ ... })
  .then(generateResumeStep)
  .commit();
```

**Marketplace Implication:** When someone "hires" a workflow, they get the composition. Individual steps could also be hireable as standalone tools.

---

### Updated Decisions Based on Conversation

| Decision | Previous | Updated | Rationale |
|----------|----------|---------|-----------|
| Output schema handling | z.record() fallback for all | z.record() only for non-terminal nodes | Terminal nodes don't need output validation |
| Visual representation | Node view only for MVP | Both List and Node views from start | Core requirement from product owner |
| Data mapping UI | Show in canvas only | Need solution for list view too | Open question - requires UX exploration |
| Step composability | Generate inline | Support importing steps from other tools | Enables marketplace model |

---

## Research Completion Checklist (Updated)

- [x] All RQ questions answered with external truth
- [x] All OQ decisions made and grounded
- [x] Primitives table complete with verified signatures
- [x] No assumptions - everything verified against docs/code
- [x] Shape of generated workflow file documented
- [x] Terminal vs non-terminal node concept captured
- [x] List view data flow question identified as open
- [x] **Verify outputParameters populated for key Composio tools** ← DONE (Dec 6, 2025)
- [ ] UX exploration for list view data mapping

---

---

## Part 6: The workflow.json Schema

The `workflow.json` file represents our **editor state** that gets translated into **executable Mastra code**.

### Relationship Between Files

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Visual Editor (React)                          │
│  - Canvas view (ReactFlow nodes/edges)                             │
│  - List view (sequential steps)                                    │
│  - Both views read/write the SAME state                            │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              │ save
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     workflow.json                                   │
│  - Editor state (positions, UI metadata)                           │
│  - Step definitions (id, type, schemas)                            │
│  - Data mappings (edges with field references)                     │
│  - Control flow (parallel groups, branches)                        │
└─────────────────────────────────────────────────────────────────────┘
                              │
                              │ transpile (deterministic)
                              ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     workflow.ts                                     │
│  - Generated Mastra code                                           │
│  - createStep() for each node                                      │
│  - .map() for each data mapping edge                               │
│  - .then(), .parallel(), .branch() for control flow               │
│  - Executable by Mastra runtime                                    │
└─────────────────────────────────────────────────────────────────────┘
```

### Proposed workflow.json Schema

Based on the existing `_tables/tools/hohoho/workflow.json` pattern, extended for Mastra:

```json
{
  "id": "job-application-workflow",
  "name": "Job Application Workflow",
  "description": "Scrapes job listings and generates tailored resumes",
  
  "inputSchema": {
    "type": "object",
    "properties": {
      "jobUrl": { "type": "string", "format": "uri" },
      "baseResume": { "type": "string" }
    },
    "required": ["jobUrl", "baseResume"]
  },
  
  "outputSchema": {
    "type": "object",
    "properties": {
      "tailoredResume": { "type": "string" }
    }
  },
  
  "steps": [
    {
      "id": "scrape-job",
      "type": "composio",                    // "composio" | "custom" | "workflow"
      "toolId": "FIRECRAWL_SCRAPE",
      "toolkitSlug": "firecrawl",
      "position": { "x": 100, "y": 200 },   // Canvas position
      "listIndex": 0,                        // List view order
      "inputSchema": { ... },                // From Composio (cached)
      "outputSchema": { ... }                // From Composio (cached)
    },
    {
      "id": "generate-resume",
      "type": "custom",
      "code": "async function execute({ inputData }) { ... }",
      "position": { "x": 400, "y": 200 },
      "listIndex": 1,
      "inputSchema": { ... },
      "outputSchema": { ... }
    }
  ],
  
  "mappings": [
    {
      "id": "mapping-1",
      "sourceStepId": "scrape-job",
      "targetStepId": "generate-resume",
      "fieldMappings": [
        { "sourcePath": "data.title", "targetField": "jobTitle" },
        { "sourcePath": "data.company", "targetField": "companyName" },
        { "sourcePath": "data.requirements", "targetField": "targetSkills" }
      ]
    }
  ],
  
  "controlFlow": {
    "type": "sequential",   // "sequential" | "parallel" | "branch"
    "order": ["scrape-job", "generate-resume"]
    // For parallel: "groups": [["step-a", "step-b"], ["step-c"]]
    // For branch: "branches": [{ "condition": "...", "stepId": "..." }]
  },
  
  "connections": {
    "firecrawl": null       // null = inherit from agent at runtime
  },
  
  "lastModified": "2025-12-06T15:30:00Z"
}
```

### Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Dual position tracking | `position` + `listIndex` | Canvas and list views need different ordering |
| Explicit mappings array | Separate from steps | Cleaner than embedding in edges; easier to edit |
| Control flow at top level | Not per-edge | Matches Mastra's workflow structure |
| Cached schemas | Stored in workflow.json | Avoids API calls to render editor |
| Step type field | `"composio"` / `"custom"` / `"workflow"` | Enables importing workflows as steps |

### Deterministic Transpilation

The workflow.json → workflow.ts translation must be **deterministic**:
- Same JSON always produces same TypeScript
- No AI/LLM involved in code generation
- Enables reliable round-tripping (edit code → see in visual editor)

---

## Next Steps

1. ~~**Verify Composio output schemas**~~ ✅ Done - outputParameters exists and is populated
2. **Finalize workflow.json schema** - Review with product owner
3. **Build code generator** - Translate workflow.json → workflow.ts
4. **UX exploration** - Prototype list view data mapping approaches
5. **Implement dual-view editor** - Both list and canvas from start
